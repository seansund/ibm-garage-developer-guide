{"componentChunkName":"component---src-pages-tools-contract-testing-with-pact-index-mdx","path":"/tools/contract-testing-with-pact/","result":{"pageContext":{"frontmatter":{"title":"Contract Testing"},"relativePagePath":"/tools/contract-testing-with-pact/index.mdx","titleType":"page","MdxNode":{"id":"a84dc5d9-5633-53ba-b21a-23fc1209bff5","children":[],"parent":"6bcd3a39-a125-5e49-bf81-d84177b612cf","internal":{"content":"---\ntitle: Contract Testing\n---\n\nimport Globals from 'gatsby-theme-carbon/src/templates/Globals';\n\n<PageDescription>\n\nUse Pact to test your code's API\n\n</PageDescription>\n\nIn IBM Garage Method, one of the Develop practices is [contract-driven testing](https://www.ibm.com/garage/method/practices/code/contract-driven-testing). [Pact](https://docs.pact.io/) automates contract testing and enables it to be added to a continuous integration pipeline. The <Globals name=\"env\" />'s CI pipeline ([Jenkins](/tools/continuous-integration), [Tekton](/tools/continuous-integration-tekton), etc.) includes a Pact stage. Simply by building your app using the CI pipeline, your code's contract gets tested, just open the Pact UI to browse the results.\n\n## What is contract testing\n\n_Contract testing_ is a testing discipline that ensures two applications (a consumer and\na provider) have a shared understanding of the interactions or the _contract_ between them.\n\nThe Pact framework has been selected for the provided tool set. Pact is a \nconsumer-driven contract testing framework. More details can be found here -\n[Pact overview](https://docs.pact.io/). The framework has been built into the <Globals name=\"templates\" />\nand a Pact Broker instance is provisioned in the cluster along with the other tools.\n\nIn `consumer-driven contract testing` it is the consumer who defines the `contract` in terms of the \nexpected interactions, the data structure, and the expected responses. That `contract` can then be used\non the consumer-side to mock the interactions and validate the consumer behavior. More importantly,\nthe `contract` can be shared with the provider of the interaction so that the provider's responses\ncan be validated to ensure the consumer's expectations are met.\n\nIn the Pact framework, the contract is called a `pact`. A `pact` consists of one or more\n`interactions`. Each `interaction` has the following structure:\n\n```\nGiven a *state* of {state}\n\n*upon receiving* a {description} request\n\n*with request* parameters\n- HTTP method\n- path\n- headers\n- body\n\n*will respond with* values like\n- status\n- headers\n- body\n```\n\nwhere:\n- {state} is an optional string that describes the initial state. This value can be used by the\nprovider during testing to make sure the preconditions are met\n- {description} is a unique description of the interaction\n- the request parameters can contain any values that describe the interaction\n- the response contains the relevant information for the consumer. The response values can be exact values\nor using matchers for type, regular expressions, etc\n\n## Consumer\n\nUsing the Pact framework libraries in conjunction with the unit testing framework on the consumer, the\n`pact` for the interaction between the consumer and provider is generated and validated. As part of the\npact test setup, a Pact server is started and configured with the expected interactions. All of the consumer\nservice invocations are directed at the Pact server which provides mock responses based on the \ninteractions defined by the `pact`. At the end of the test, if all the interactions completed successfully\na file containing the pact definition is generated.\n\nThe following diagram gives an overview of the consumer interactions:\n![Pact consumer interactions](./PactFramework-consumer.png)\n\nAn example pact test on a Typescript consumer using the jest testing framework is provided below. It has\nbeen broken into several parts.\n\n### Pact server config\n\nAt the beginning of the test file, the pact server is configured and started in the\n`beforeAll()` block. The `afterAll()` block finalizes the pacts by writing them out\nto a file and stopping the pact server.\n\n```typescript\n  const port = 1234;\n  const baseUrl = `http://localhost:${port}`;\n  let pact: Pact;\n  beforeAll(() => {\n    pact = new Pact({\n      consumer: consumerName,\n      provider: providerName,\n      logLevel: 'error',\n      port,\n    });\n\n    return pact.setup();\n  });\n\n  afterAll(() => {\n    return pact.finalize()\n      .catch(err => console.error('Error finalizing pact', err));\n  });\n```\n\n### Setup the service\n\nNext, an instance of the component that will be tested is loaded and configured with the \npact server host and port as the base url used for the interactions. In this example,\nthe consumer is using the `typescript-ioc` library to inject the `baseUrl` config value \ninto the service.\n\n```typescript  \n  let service: SampleApi;\n  beforeAll(() => {\n    Container\n      .bind(MyServiceConfig)\n      .provider({get: () => ({baseUrl})});\n    \n    service = Container.get(SampleService);\n  });\n```\n\n### Define and test the interaction\n\nFor each interaction with the provider, a test similar to the one provided below is created. In\nit, the Pact framework is used to define the interaction. The `addInteraction()` publishes the\ninteraction to the Pact server so that it can be used to provide a mock response when the\nrequest is made.\n\nThe mock response is then used to validate the behavior of the component that is being tested.\nThe example below is simple and passes the provider response directly through the service api\nbut in more sophisticated examples the value would be transformed.\n\n```typescript\n  describe('given createWidget()', () => {\n    context('when called with valid request', () => {\n      const widgetRequest = {...};\n      const widgetResponse = {...};\n      \n      beforeEach(() => {\n        return pact.addInteraction({\n          uponReceiving: 'a valid widget request',\n          withRequest: {\n            method: 'POST',\n            path: '/widgets',\n            headers: {\n              'Content-Type': 'application/json',\n              'Accept': 'application/json',\n            },\n            body: widgetRequest,\n          },\n          willRespondWith: {\n            status: 200,\n            headers: {\n              'Content-Type': Matchers.regex({\n                generate: 'application/json', matcher: 'application/json.*'\n              }),\n            },\n            body: Matchers.like(widgetResponse),\n          },\n        });\n      });\n\n      test('then return 200 status', async () => {\n        expect(await service.createWidget(widgetRequest)).toEqual(widgetResponse);\n      });\n    });\n  });\n```\n\n## Provider\n\nThe provider uses the Pact framework to verify the running server against the `pact`, either\none started locally as part of the test or another instance running elsewhere. The interactions\nin the pact are sent to the provider by a mock consumer in the Pact framework and the results\nare verified against the expected results defined by the pact.\n\nAs an optional configuration for the verification process, an endpoint can be provided that handles\nthe state information in the pact in order to ensure the preconditions for the test are met. (E.g.\nstate=\"given an empty database\"). In order for these tests to be repeatable, it is often advisable\nto stand up a clean backend to run the pact tests when the tests start and tear it down when the\ntests are completed. For example, if a provider interacts with a Cloudant database point the \ntest provider at a new database instance for the tests.\n\nThe following diagram shows the interactions for the pact provider:\n![Pact provider interactions](./PactFramework-provider.png)\n\n## Pact Broker\n\nOne of the underpinning requirements of the pact verification process is the ability to make the\npact files generated by the consumer available to the provider. When the pact verification is run\nin an automated pipeline this is difficult without an intermediary. Within the Pact framework,\nthe `Pact Broker` provides the facility for consumers and providers to share the pact definitions\nwith minimal dependencies between the systems.\n\nAdditionally, the Pact Broker provides a place to define webhooks to trigger the provider build\nprocess when the pact definition changes and a way record and visualise the results of the\nverification process. The high-level interaction is shown below:\n![Pact broker interactions](./PactFramework-pactbroker.png)\n\n## <Globals name=\"templates\" />\n\nThe <Globals name=\"templates\" /> have been built with the frameworks necessary to generate and publish pacts for\napi consumers and verify against pacts and publish the results for api providers. The pipelines \nwill do all the publishing and verification against Pact Broker if an instance of Pact Broker has\nbeen configured within the cluster.\n\n- You can review you pact contracts using the **Pact** Dashboard.app\n\n- Use the [<Globals name=\"dashboard\" />](/getting-started/dashboard) to open the **Pact** dashboard\n\n\n","type":"Mdx","contentDigest":"8609889312add93aadc05c13848e5c7e","counter":1003,"owner":"gatsby-plugin-mdx"},"frontmatter":{"title":"Contract Testing"},"exports":{},"rawBody":"---\ntitle: Contract Testing\n---\n\nimport Globals from 'gatsby-theme-carbon/src/templates/Globals';\n\n<PageDescription>\n\nUse Pact to test your code's API\n\n</PageDescription>\n\nIn IBM Garage Method, one of the Develop practices is [contract-driven testing](https://www.ibm.com/garage/method/practices/code/contract-driven-testing). [Pact](https://docs.pact.io/) automates contract testing and enables it to be added to a continuous integration pipeline. The <Globals name=\"env\" />'s CI pipeline ([Jenkins](/tools/continuous-integration), [Tekton](/tools/continuous-integration-tekton), etc.) includes a Pact stage. Simply by building your app using the CI pipeline, your code's contract gets tested, just open the Pact UI to browse the results.\n\n## What is contract testing\n\n_Contract testing_ is a testing discipline that ensures two applications (a consumer and\na provider) have a shared understanding of the interactions or the _contract_ between them.\n\nThe Pact framework has been selected for the provided tool set. Pact is a \nconsumer-driven contract testing framework. More details can be found here -\n[Pact overview](https://docs.pact.io/). The framework has been built into the <Globals name=\"templates\" />\nand a Pact Broker instance is provisioned in the cluster along with the other tools.\n\nIn `consumer-driven contract testing` it is the consumer who defines the `contract` in terms of the \nexpected interactions, the data structure, and the expected responses. That `contract` can then be used\non the consumer-side to mock the interactions and validate the consumer behavior. More importantly,\nthe `contract` can be shared with the provider of the interaction so that the provider's responses\ncan be validated to ensure the consumer's expectations are met.\n\nIn the Pact framework, the contract is called a `pact`. A `pact` consists of one or more\n`interactions`. Each `interaction` has the following structure:\n\n```\nGiven a *state* of {state}\n\n*upon receiving* a {description} request\n\n*with request* parameters\n- HTTP method\n- path\n- headers\n- body\n\n*will respond with* values like\n- status\n- headers\n- body\n```\n\nwhere:\n- {state} is an optional string that describes the initial state. This value can be used by the\nprovider during testing to make sure the preconditions are met\n- {description} is a unique description of the interaction\n- the request parameters can contain any values that describe the interaction\n- the response contains the relevant information for the consumer. The response values can be exact values\nor using matchers for type, regular expressions, etc\n\n## Consumer\n\nUsing the Pact framework libraries in conjunction with the unit testing framework on the consumer, the\n`pact` for the interaction between the consumer and provider is generated and validated. As part of the\npact test setup, a Pact server is started and configured with the expected interactions. All of the consumer\nservice invocations are directed at the Pact server which provides mock responses based on the \ninteractions defined by the `pact`. At the end of the test, if all the interactions completed successfully\na file containing the pact definition is generated.\n\nThe following diagram gives an overview of the consumer interactions:\n![Pact consumer interactions](./PactFramework-consumer.png)\n\nAn example pact test on a Typescript consumer using the jest testing framework is provided below. It has\nbeen broken into several parts.\n\n### Pact server config\n\nAt the beginning of the test file, the pact server is configured and started in the\n`beforeAll()` block. The `afterAll()` block finalizes the pacts by writing them out\nto a file and stopping the pact server.\n\n```typescript\n  const port = 1234;\n  const baseUrl = `http://localhost:${port}`;\n  let pact: Pact;\n  beforeAll(() => {\n    pact = new Pact({\n      consumer: consumerName,\n      provider: providerName,\n      logLevel: 'error',\n      port,\n    });\n\n    return pact.setup();\n  });\n\n  afterAll(() => {\n    return pact.finalize()\n      .catch(err => console.error('Error finalizing pact', err));\n  });\n```\n\n### Setup the service\n\nNext, an instance of the component that will be tested is loaded and configured with the \npact server host and port as the base url used for the interactions. In this example,\nthe consumer is using the `typescript-ioc` library to inject the `baseUrl` config value \ninto the service.\n\n```typescript  \n  let service: SampleApi;\n  beforeAll(() => {\n    Container\n      .bind(MyServiceConfig)\n      .provider({get: () => ({baseUrl})});\n    \n    service = Container.get(SampleService);\n  });\n```\n\n### Define and test the interaction\n\nFor each interaction with the provider, a test similar to the one provided below is created. In\nit, the Pact framework is used to define the interaction. The `addInteraction()` publishes the\ninteraction to the Pact server so that it can be used to provide a mock response when the\nrequest is made.\n\nThe mock response is then used to validate the behavior of the component that is being tested.\nThe example below is simple and passes the provider response directly through the service api\nbut in more sophisticated examples the value would be transformed.\n\n```typescript\n  describe('given createWidget()', () => {\n    context('when called with valid request', () => {\n      const widgetRequest = {...};\n      const widgetResponse = {...};\n      \n      beforeEach(() => {\n        return pact.addInteraction({\n          uponReceiving: 'a valid widget request',\n          withRequest: {\n            method: 'POST',\n            path: '/widgets',\n            headers: {\n              'Content-Type': 'application/json',\n              'Accept': 'application/json',\n            },\n            body: widgetRequest,\n          },\n          willRespondWith: {\n            status: 200,\n            headers: {\n              'Content-Type': Matchers.regex({\n                generate: 'application/json', matcher: 'application/json.*'\n              }),\n            },\n            body: Matchers.like(widgetResponse),\n          },\n        });\n      });\n\n      test('then return 200 status', async () => {\n        expect(await service.createWidget(widgetRequest)).toEqual(widgetResponse);\n      });\n    });\n  });\n```\n\n## Provider\n\nThe provider uses the Pact framework to verify the running server against the `pact`, either\none started locally as part of the test or another instance running elsewhere. The interactions\nin the pact are sent to the provider by a mock consumer in the Pact framework and the results\nare verified against the expected results defined by the pact.\n\nAs an optional configuration for the verification process, an endpoint can be provided that handles\nthe state information in the pact in order to ensure the preconditions for the test are met. (E.g.\nstate=\"given an empty database\"). In order for these tests to be repeatable, it is often advisable\nto stand up a clean backend to run the pact tests when the tests start and tear it down when the\ntests are completed. For example, if a provider interacts with a Cloudant database point the \ntest provider at a new database instance for the tests.\n\nThe following diagram shows the interactions for the pact provider:\n![Pact provider interactions](./PactFramework-provider.png)\n\n## Pact Broker\n\nOne of the underpinning requirements of the pact verification process is the ability to make the\npact files generated by the consumer available to the provider. When the pact verification is run\nin an automated pipeline this is difficult without an intermediary. Within the Pact framework,\nthe `Pact Broker` provides the facility for consumers and providers to share the pact definitions\nwith minimal dependencies between the systems.\n\nAdditionally, the Pact Broker provides a place to define webhooks to trigger the provider build\nprocess when the pact definition changes and a way record and visualise the results of the\nverification process. The high-level interaction is shown below:\n![Pact broker interactions](./PactFramework-pactbroker.png)\n\n## <Globals name=\"templates\" />\n\nThe <Globals name=\"templates\" /> have been built with the frameworks necessary to generate and publish pacts for\napi consumers and verify against pacts and publish the results for api providers. The pipelines \nwill do all the publishing and verification against Pact Broker if an instance of Pact Broker has\nbeen configured within the cluster.\n\n- You can review you pact contracts using the **Pact** Dashboard.app\n\n- Use the [<Globals name=\"dashboard\" />](/getting-started/dashboard) to open the **Pact** dashboard\n\n\n","fileAbsolutePath":"/home/runner/work/ibm-garage-developer-guide/ibm-garage-developer-guide/src/pages/tools/contract-testing-with-pact/index.mdx"}}},"staticQueryHashes":["1364590287","2102389209","2102389209","2456312558","2746626797","2746626797","3018647132","3018647132","3037994772","3037994772","3273249464","63531786","63531786","768070550"]}