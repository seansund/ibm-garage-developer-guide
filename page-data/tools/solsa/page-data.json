{"componentChunkName":"component---src-pages-tools-solsa-index-mdx","path":"/tools/solsa/","result":{"pageContext":{"frontmatter":{"title":"Architecture as Code with SolSA"},"relativePagePath":"/tools/solsa/index.mdx","titleType":"page","MdxNode":{"id":"ab2722b2-9131-5348-9b97-20ee06d01090","children":[],"parent":"fb605df1-31cd-5876-9c28-1e08b51f4e85","internal":{"content":"---\ntitle: Architecture as Code with SolSA\n---\n\n<PageDescription>\n\nSolSA makes it possible to specify the software architecture of Kubernetes-managed cloud applications as JavaScript or TypeScript programs.\n\n</PageDescription>\n\n## Overview\n\nKubernetes is becoming the de facto standard for managing applications in the cloud. Thanks to [operators](https://operatorhub.io/), Kubernetes can be extended to manage virtually any kind of application resources: not only containers and microservices, but also virtual machines, cloud functions and events, managed cloud services, policies, meshes, etc. Each resource can be declared and configured with a few lines of YAML. However, while YAML is a fine language to perform some basic configuration, SolSA is designed to enable application developers to reason about applications at a higher-level of abstraction using familiar languages and development tools.\n\nThe SolSA library for Node.js —a shorthand for Solution Service Architecture — makes it possible to specify the architecture of cloud applications as programs. SolSA enables developers to configure Kubernetes-managed resources by writing JavaScript or TypeScript code instead of YAML. SolSA automatically translates the developer written code to the required lower-level YAML. SolSA integrates with IDEs such as Visual Studio Code to provide online validation, code completion, and documentation of the various resources and configuration parameters.\n\n## Getting Started\n\nThe `solsa` CLI is included in the [Tools Image](/tools/tools-image) and is pre-configured as a plugin to the [ArgoCD instance](/tools/continuous-delivery) installed in the `tools` namespace of your cluster. No further setup is needed for basic usage of SolSA.  To enable full IDE support, you will need to install the `solsa` package using npm in the same manner in which you would install any npm package you want to use in your IDE. Some typical installation options are discussed in the [SolSA setup instructions](https://github.com/IBM/solsa#solsa-setup).\n\n## Usage Scenarios\n\nSolSA can be applied in any scenario where it is desirable to use a higher-level of abstraction to programmatically generate YAML to be applied to a Kubernetes or OpenShift cluster.  The use of SolSA is particularly compelling to:\n  - Specify the architecture of complex applications composed of multiple Kubernetes resources. SolSA augments the base Kubernetes resources with additional abstractions that simplify the specification of common patterns and reduce the amount of code written.\n  - Enable full IDE-support for your software architecture, including validation, code assist, and integrated documentation of Kubernetes resources and operators.\n  - Allow a single architecture specification to be programmatically specialized to different contexts (eg. dev vs. test vs. prod).\n\n### Specification of Kubernetes Resources\n\nDeploying just a single microservice that is accessible outside of a Kubernetes cluster requires specifying three related Kubernetes resources: a `Deployment`, a `Service`, and an `Ingress`. SolSA simplifies this task by reducing the amount of repetitive code a developer needs to write and maintain.\n\nTo illustrate how to use SolSA to specify the architecture of a simple cloud native application, we use the [Bookinfo sample application](https://istio.io/docs/examples/bookinfo/) from the Istio project. Bookinfo consists of four containerized microservices: an externally exposed productpage service that is implemented using three internal backend microservices.\n\nThe tabs below contain two variants of the SolSA specification of Bookinfo's architecture and the (identical) Kubernetes YAML that is generated from either one of these specifications by the `solsa` CLI.\n\n<Tabs>\n\n<Tab label=\"SolSA ContainerizedService\">\n\nA very common Kubernetes pattern is the combination of a `Deployment` and a `Service` to implement a single logical microservice. SolSA's `ContainerizedService` provides a higher level abstraction for this pattern that allows the developer to specify the essential elements while eliding virtually all of the Kubernetes-specific details. As shown below, simple microservices can be specified very concisely. By providing additional arguments to the `ContainerizedService` constructor it is possible to control many aspects of the generated YAML. Specifying that the `productpage` service should be exposed outside the cluster is declared by invoking `getIngress` passing the desired virtual host name `bookinfo`.\n\n```javascript\nlet solsa = require('solsa')\n\nlet details = new solsa.ContainerizedService({ name: 'details', image: 'istio/examples-bookinfo-details-v1:1.15.0', port: 9080 })\nlet ratings = new solsa.ContainerizedService({ name: 'ratings', image: 'istio/examples-bookinfo-ratings-v1:1.15.0', port: 9080 })\nlet reviews = new solsa.ContainerizedService({ name: 'reviews', image: 'istio/examples-bookinfo-reviews-v1:1.15.0', port: 9080 })\nlet productpage = new solsa.ContainerizedService({ name: 'productpage', image: 'istio/examples-bookinfo-productpage-v1:1.15.0', port: 9080 })\nproductpage.env = {\n  DETAILS_HOSTNAME: details.name,\n  RATINGS_HOSTNAME: ratings.name,\n  REVIEWS_HOSTNAME: reviews.name\n}\nlet entry = productpage.getIngress({ vhost: 'bookinfo' })\n\nmodule.exports = new solsa.Bundle({ details, ratings, reviews, productpage, entry })\n```\n\n</Tab>\n\n<Tab label=\"SolSA Deployment\">\n\nThe SolSA library includes fully integrated support for all Kubernetes resource types. The (much larger) code block below shows how Bookinfo would be specified in SolSA directly using the Kubernetes native concept of `Deployment`.  Working at this lower level of abstraction requires that the developer be more familiar with Kubernetes concepts, but enables full control over all aspects of the generated YAML.  Notice that even when working directly with `Deployment`, the developer is still able to elide the details of the `Service` and `Ingress` resources by using SolSA's `getService` and `getIngress` methods which derive all the necessary information the underlying `Deployment`. Thus even when working at a Kubernetes-native level of abstraction, SolSA can eliminate some of the repetitive and error prone coding present when working purely at the YAML level.\n\n```javascript\nlet solsa = require('solsa')\n\nlet details = new solsa.apps.v1.Deployment({\n  metadata: { name: 'details' },\n  spec: {\n    selector: { matchLabels: { 'solsa.ibm.com/pod': 'details' } },\n    replicas: 1,\n    template: {\n      spec: {\n        containers: [\n          {\n            name: 'details',\n            image: 'istio/examples-bookinfo-details-v1:1.15.0',\n            env: [{ name: 'PORT', value: '9080' }],\n            ports: [{ containerPort: 9080 }],\n            livenessProbe: { tcpSocket: { port: 9080 } },\n            readinessProbe: { tcpSocket: { port: 9080 } }\n          }\n        ]\n      }\n    }\n  }\n})\nlet detailsService = details.getService()\n\nlet reviews = new solsa.apps.v1.Deployment({\n  metadata: { name: 'reviews' },\n  spec: {\n    selector: { matchLabels: { 'solsa.ibm.com/pod': 'reviews' } },\n    replicas: 1,\n    template: {\n      spec: {\n        containers: [\n          {\n            name: 'reviews',\n            image: 'istio/examples-bookinfo-reviews-v1:1.15.0',\n            env: [{ name: 'PORT', value: '9080' }],\n            ports: [{ containerPort: 9080 }],\n            livenessProbe: { tcpSocket: { port: 9080 } },\n            readinessProbe: { tcpSocket: { port: 9080 } }\n          }\n        ]\n      }\n    }\n  }\n})\nlet reviewsService = reviews.getService()\n\nlet ratings = new solsa.apps.v1.Deployment({\n  metadata: { name: 'ratings' },\n  spec: {\n    selector: { matchLabels: { 'solsa.ibm.com/pod': 'ratings' } },\n    replicas: 1,\n    template: {\n      spec: {\n        containers: [\n          {\n            name: 'ratings',\n            image: 'istio/examples-bookinfo-ratings-v1:1.15.0',\n            env: [{ name: 'PORT', value: '9080' }],\n            ports: [{ containerPort: 9080 }],\n            livenessProbe: { tcpSocket: { port: 9080 } },\n            readinessProbe: { tcpSocket: { port: 9080 } }\n          }\n        ]\n      }\n    }\n  }\n})\nlet ratingsService = ratings.getService()\n\nlet productpage = new solsa.apps.v1.Deployment({\n  metadata: { name: 'productpage' },\n  spec: {\n    selector: { matchLabels: { 'solsa.ibm.com/pod': 'productpage' } },\n    replicas: 1,\n    template: {\n      spec: {\n        containers: [\n          {\n            name: 'productpage',\n            image: 'istio/examples-bookinfo-productpage-v1:1.15.0',\n            env: [\n              { name: 'PORT', value: '9080' },\n              { name: 'DETAILS_HOSTNAME', value: details.metadata.name },\n              { name: 'RATINGS_HOSTNAME', value: ratings.metadata.name },\n              { name: 'REVIEWS_HOSTNAME', value: reviews.metadata.name }\n            ],\n            ports: [{ containerPort: 9080 }],\n            livenessProbe: { tcpSocket: { port: 9080 } },\n            readinessProbe: { tcpSocket: { port: 9080 } }\n          }\n        ]\n      }\n    }\n  }\n})\nlet productpageService = productpage.getService()\nlet ingress = productpageService.getIngress({ vhost: 'bookinfo' })\n\nmodule.exports = new solsa.Bundle({ details, detailsService, reviews, reviewsService, ratings, ratingsService, productpage, productpageService, ingress })\n```\n\n</Tab>\n\n<Tab label=\"Generated YAML\">\n\nShown below is the output from `solsa yaml` when applied to either of the two Bookinfo specifications.\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: details\nspec:\n  ports:\n  - port: 9080\n    targetPort: 9080\n  selector:\n    solsa.ibm.com/pod: details\n  type: ClusterIP\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: productpage\nspec:\n  ports:\n  - port: 9080\n    targetPort: 9080\n  selector:\n    solsa.ibm.com/pod: productpage\n  type: ClusterIP\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: ratings\nspec:\n  ports:\n  - port: 9080\n    targetPort: 9080\n  selector:\n    solsa.ibm.com/pod: ratings\n  type: ClusterIP\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: reviews\nspec:\n  ports:\n  - port: 9080\n    targetPort: 9080\n  selector:\n    solsa.ibm.com/pod: reviews\n  type: ClusterIP\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: details\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      solsa.ibm.com/pod: details\n  template:\n    metadata:\n      labels:\n        solsa.ibm.com/pod: details\n    spec:\n      containers:\n      - env:\n        - name: PORT\n          value: \"9080\"\n        image: istio/examples-bookinfo-details-v1:1.15.0\n        livenessProbe:\n          tcpSocket:\n            port: 9080\n        name: details\n        ports:\n        - containerPort: 9080\n        readinessProbe:\n          tcpSocket:\n            port: 9080\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: productpage\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      solsa.ibm.com/pod: productpage\n  template:\n    metadata:\n      labels:\n        solsa.ibm.com/pod: productpage\n    spec:\n      containers:\n      - env:\n        - name: PORT\n          value: \"9080\"\n        - name: DETAILS_HOSTNAME\n          value: details\n        - name: RATINGS_HOSTNAME\n          value: ratings\n        - name: REVIEWS_HOSTNAME\n          value: reviews\n        image: istio/examples-bookinfo-productpage-v1:1.15.0\n        livenessProbe:\n          tcpSocket:\n            port: 9080\n        name: productpage\n        ports:\n        - containerPort: 9080\n        readinessProbe:\n          tcpSocket:\n            port: 9080\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: ratings\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      solsa.ibm.com/pod: ratings\n  template:\n    metadata:\n      labels:\n        solsa.ibm.com/pod: ratings\n    spec:\n      containers:\n      - env:\n        - name: PORT\n          value: \"9080\"\n        image: istio/examples-bookinfo-ratings-v1:1.15.0\n        livenessProbe:\n          tcpSocket:\n            port: 9080\n        name: ratings\n        ports:\n        - containerPort: 9080\n        readinessProbe:\n          tcpSocket:\n            port: 9080\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: reviews\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      solsa.ibm.com/pod: reviews\n  template:\n    metadata:\n      labels:\n        solsa.ibm.com/pod: reviews\n    spec:\n      containers:\n      - env:\n        - name: PORT\n          value: \"9080\"\n        image: istio/examples-bookinfo-reviews-v1:1.15.0\n        livenessProbe:\n          tcpSocket:\n            port: 9080\n        name: reviews\n        ports:\n        - containerPort: 9080\n        readinessProbe:\n          tcpSocket:\n            port: 9080\n---\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: productpage\nspec:\n  rules:\n  - host: bookinfo.mycluster.us-east.containers.appdomain.cloud\n    http:\n      paths:\n      - backend:\n          serviceName: productpage\n          servicePort: 9080\n        path: /\n  tls:\n  - hosts:\n    - bookinfo.mycluster.us-east.containers.appdomain.cloud\n    secretName: mycluster\n```\n\n</Tab>\n\n</Tabs>\n\n\n### Using SolSA with Kubernetes Operators\n\nThe SolSA library includes JavaScript/TypeScript bindings for every Kubernetes Operator available on\n[OperatorHub.io](https://operatorhub.io/).  These enables full IDE-support for defining applications that utilize operators to manage the life-cycles of some portions of their resources.\n\nAs an example, the tabs below show the SolSA specification and the generated YAML of a simple language translation application in which a microservice defined using SolSA's `ContainerzedService` abstraction is combined with an instance of the Watson Translator service on the IBM Public Cloud. The IBM Cloud Operator is used to instantiate the Watson Translator Service instance and make the credentials for accessing it available to the dependent microservice via a Kubernetes secret.\n\n<Tabs>\n\n<Tab label=\"SolSA\">\n\n```javascript\n\nconst path = require('path')\nconst solsa = require('solsa')\n\nfunction translator ({ name, language }) {\n  let watson = new solsa.LanguageTranslator({ name: 'watson-translator-for-' + name })\n  let translator = new solsa.ContainerizedService({ name, image: 'solsa-translator', build: path.join(__dirname, 'solsa-translator'), port: 8080 })\n  translator.env = { LANGUAGE: { value: language }, WATSON_URL: watson.getSecret('url'), WATSON_APIKEY: watson.getSecret('apikey') }\n  let ingress = translator.getIngress()\n  return new solsa.Bundle({ watson, translator, ingress })\n}\n\nmodule.exports = translator({ name: 'my-translator', language: 'en' })\n```\n\n</Tab>\n\n<Tab label=\"YAML\">\n\n```yaml\napiVersion: ibmcloud.ibm.com/v1alpha1\nkind: Service\nmetadata:\n  name: watson-translator-for-my-translator\nspec:\n  plan: lite\n  serviceClass: language-translator\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: my-translator\nspec:\n  ports:\n  - port: 8080\n    targetPort: 8080\n  selector:\n    solsa.ibm.com/pod: my-translator\n  type: ClusterIP\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-translator\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      solsa.ibm.com/pod: my-translator\n  template:\n    metadata:\n      labels:\n        solsa.ibm.com/pod: my-translator\n    spec:\n      containers:\n      - env:\n        - name: PORT\n          value: \"8080\"\n        - name: LANGUAGE\n          value: en\n        - name: WATSON_URL\n          valueFrom:\n            secretKeyRef:\n              key: url\n              name: watson-translator-for-my-translator\n        - name: WATSON_APIKEY\n          valueFrom:\n            secretKeyRef:\n              key: apikey\n              name: watson-translator-for-my-translator\n        image: docker.io/solsa/solsa-translator\n        livenessProbe:\n          tcpSocket:\n            port: 8080\n        name: my-translator\n        ports:\n        - containerPort: 8080\n        readinessProbe:\n          tcpSocket:\n            port: 8080\n---\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: my-translator\nspec:\n  rules:\n  - host: my-translator.mycluster.us-east.containers.appdomain.cloud\n    http:\n      paths:\n      - backend:\n          serviceName: my-translator\n          servicePort: 8080\n        path: /\n  tls:\n  - hosts:\n    - my-translator.mycluster.us-east.containers.appdomain.cloud\n    secretName: mycluster\n---\napiVersion: ibmcloud.ibm.com/v1alpha1\nkind: Binding\nmetadata:\n  name: watson-translator-for-my-translator\nspec:\n  serviceName: watson-translator-for-my-translator\n\n```\n</Tab>\n\n</Tabs>\n\n\n### Using SolSA with ArgoCD\n\nThe usage of ArgoCD is described in more detail in the [continuous delivery](/tools/continuous-delivery/) section of this guide. A SolSA-specified application can be used in exactly the same workflows as an application specified by a Helm chart or Kustomize tree. The only additional step is to inform ArgoCD that it should use its SolSA plugin to generate the YAML for the application. In the instructions below, we will continue using the Bookinfo sample from the [solsa-examples](https://github.com/IBM/solsa-examples) git repo. The main SolSA file for this application is `instance.js`\n\n<Tabs>\n\n<Tab label=\"ArgoCD UI\">\n\n1. Log into ArgoCD\n\n2. Click `New Application` and provide the following values:\n\n    - `application name` - dev-bookinfo\n    - `project` - default\n    - `sync-policy` - `Automatic with pruning`\n    - `repository url` - https://github.com/IBM/solsa-examples.git\n    - `revision` - HEAD\n    - `path` - examples/bookinfo\n    - `destination cluster` - https://kubernetes.default.svc\n    - `destination namespace` - dev\n\n3. Click the `EDIT AS YAML` button and add the plugin stanza shown below to the `source:` block\n```yaml\nsource:\n  plugin:\n    name: solsa\n    env:\n      - name: SOLSA_APP_MAIN\n        value: instance.js\n```\n\nFinally deploy Bookinfo by clicking the Create button.\n\n</Tab>\n\n<Tab label=\"Textual CRD\">\n\nArgoCD Applications can also be specified without using the ArgoCD UI by defining an `argoproj.io.Application` Custom Resource. In this style of management you\ncreate a `bookinfoApp.yaml` file containing the YAML shown below and then either check it into a git repo that ArgoCD is monitoring\nor directly apply it to your cluster via `kubectl apply -f bookinfoApp.yaml -n tools`. Within a few seconds, the Bookinfo application should be deployed to your `dev` namespace.\n\n```yaml\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: bookinfo\nspec:\n  project: default\n  source:\n    repoURL: 'https://github.com/IBM/solsa-examples.git'\n    path: examples/bookinfo\n    targetRevision: HEAD\n    plugin:\n      name: solsa\n      env:\n        - name: SOLSA_APP_MAIN\n          value: instance.js\n  destination:\n    server: 'https://kubernetes.default.svc'\n    namespace: dev\n  syncPolicy:\n    automated:\n      prune: true\n```\n\n</Tab>\n\n</Tabs>\n\n## More Information\n\nAdditional information on SolSA, including [a tutorial and sample applications](https://github.com/IBM/solsa-examples), is available from the [SolSA open source project](https://github.com/IBM/solsa).\n","type":"Mdx","contentDigest":"de8b75d77f64c694eed2db1ab220fdf2","counter":1010,"owner":"gatsby-plugin-mdx"},"frontmatter":{"title":"Architecture as Code with SolSA"},"exports":{},"rawBody":"---\ntitle: Architecture as Code with SolSA\n---\n\n<PageDescription>\n\nSolSA makes it possible to specify the software architecture of Kubernetes-managed cloud applications as JavaScript or TypeScript programs.\n\n</PageDescription>\n\n## Overview\n\nKubernetes is becoming the de facto standard for managing applications in the cloud. Thanks to [operators](https://operatorhub.io/), Kubernetes can be extended to manage virtually any kind of application resources: not only containers and microservices, but also virtual machines, cloud functions and events, managed cloud services, policies, meshes, etc. Each resource can be declared and configured with a few lines of YAML. However, while YAML is a fine language to perform some basic configuration, SolSA is designed to enable application developers to reason about applications at a higher-level of abstraction using familiar languages and development tools.\n\nThe SolSA library for Node.js —a shorthand for Solution Service Architecture — makes it possible to specify the architecture of cloud applications as programs. SolSA enables developers to configure Kubernetes-managed resources by writing JavaScript or TypeScript code instead of YAML. SolSA automatically translates the developer written code to the required lower-level YAML. SolSA integrates with IDEs such as Visual Studio Code to provide online validation, code completion, and documentation of the various resources and configuration parameters.\n\n## Getting Started\n\nThe `solsa` CLI is included in the [Tools Image](/tools/tools-image) and is pre-configured as a plugin to the [ArgoCD instance](/tools/continuous-delivery) installed in the `tools` namespace of your cluster. No further setup is needed for basic usage of SolSA.  To enable full IDE support, you will need to install the `solsa` package using npm in the same manner in which you would install any npm package you want to use in your IDE. Some typical installation options are discussed in the [SolSA setup instructions](https://github.com/IBM/solsa#solsa-setup).\n\n## Usage Scenarios\n\nSolSA can be applied in any scenario where it is desirable to use a higher-level of abstraction to programmatically generate YAML to be applied to a Kubernetes or OpenShift cluster.  The use of SolSA is particularly compelling to:\n  - Specify the architecture of complex applications composed of multiple Kubernetes resources. SolSA augments the base Kubernetes resources with additional abstractions that simplify the specification of common patterns and reduce the amount of code written.\n  - Enable full IDE-support for your software architecture, including validation, code assist, and integrated documentation of Kubernetes resources and operators.\n  - Allow a single architecture specification to be programmatically specialized to different contexts (eg. dev vs. test vs. prod).\n\n### Specification of Kubernetes Resources\n\nDeploying just a single microservice that is accessible outside of a Kubernetes cluster requires specifying three related Kubernetes resources: a `Deployment`, a `Service`, and an `Ingress`. SolSA simplifies this task by reducing the amount of repetitive code a developer needs to write and maintain.\n\nTo illustrate how to use SolSA to specify the architecture of a simple cloud native application, we use the [Bookinfo sample application](https://istio.io/docs/examples/bookinfo/) from the Istio project. Bookinfo consists of four containerized microservices: an externally exposed productpage service that is implemented using three internal backend microservices.\n\nThe tabs below contain two variants of the SolSA specification of Bookinfo's architecture and the (identical) Kubernetes YAML that is generated from either one of these specifications by the `solsa` CLI.\n\n<Tabs>\n\n<Tab label=\"SolSA ContainerizedService\">\n\nA very common Kubernetes pattern is the combination of a `Deployment` and a `Service` to implement a single logical microservice. SolSA's `ContainerizedService` provides a higher level abstraction for this pattern that allows the developer to specify the essential elements while eliding virtually all of the Kubernetes-specific details. As shown below, simple microservices can be specified very concisely. By providing additional arguments to the `ContainerizedService` constructor it is possible to control many aspects of the generated YAML. Specifying that the `productpage` service should be exposed outside the cluster is declared by invoking `getIngress` passing the desired virtual host name `bookinfo`.\n\n```javascript\nlet solsa = require('solsa')\n\nlet details = new solsa.ContainerizedService({ name: 'details', image: 'istio/examples-bookinfo-details-v1:1.15.0', port: 9080 })\nlet ratings = new solsa.ContainerizedService({ name: 'ratings', image: 'istio/examples-bookinfo-ratings-v1:1.15.0', port: 9080 })\nlet reviews = new solsa.ContainerizedService({ name: 'reviews', image: 'istio/examples-bookinfo-reviews-v1:1.15.0', port: 9080 })\nlet productpage = new solsa.ContainerizedService({ name: 'productpage', image: 'istio/examples-bookinfo-productpage-v1:1.15.0', port: 9080 })\nproductpage.env = {\n  DETAILS_HOSTNAME: details.name,\n  RATINGS_HOSTNAME: ratings.name,\n  REVIEWS_HOSTNAME: reviews.name\n}\nlet entry = productpage.getIngress({ vhost: 'bookinfo' })\n\nmodule.exports = new solsa.Bundle({ details, ratings, reviews, productpage, entry })\n```\n\n</Tab>\n\n<Tab label=\"SolSA Deployment\">\n\nThe SolSA library includes fully integrated support for all Kubernetes resource types. The (much larger) code block below shows how Bookinfo would be specified in SolSA directly using the Kubernetes native concept of `Deployment`.  Working at this lower level of abstraction requires that the developer be more familiar with Kubernetes concepts, but enables full control over all aspects of the generated YAML.  Notice that even when working directly with `Deployment`, the developer is still able to elide the details of the `Service` and `Ingress` resources by using SolSA's `getService` and `getIngress` methods which derive all the necessary information the underlying `Deployment`. Thus even when working at a Kubernetes-native level of abstraction, SolSA can eliminate some of the repetitive and error prone coding present when working purely at the YAML level.\n\n```javascript\nlet solsa = require('solsa')\n\nlet details = new solsa.apps.v1.Deployment({\n  metadata: { name: 'details' },\n  spec: {\n    selector: { matchLabels: { 'solsa.ibm.com/pod': 'details' } },\n    replicas: 1,\n    template: {\n      spec: {\n        containers: [\n          {\n            name: 'details',\n            image: 'istio/examples-bookinfo-details-v1:1.15.0',\n            env: [{ name: 'PORT', value: '9080' }],\n            ports: [{ containerPort: 9080 }],\n            livenessProbe: { tcpSocket: { port: 9080 } },\n            readinessProbe: { tcpSocket: { port: 9080 } }\n          }\n        ]\n      }\n    }\n  }\n})\nlet detailsService = details.getService()\n\nlet reviews = new solsa.apps.v1.Deployment({\n  metadata: { name: 'reviews' },\n  spec: {\n    selector: { matchLabels: { 'solsa.ibm.com/pod': 'reviews' } },\n    replicas: 1,\n    template: {\n      spec: {\n        containers: [\n          {\n            name: 'reviews',\n            image: 'istio/examples-bookinfo-reviews-v1:1.15.0',\n            env: [{ name: 'PORT', value: '9080' }],\n            ports: [{ containerPort: 9080 }],\n            livenessProbe: { tcpSocket: { port: 9080 } },\n            readinessProbe: { tcpSocket: { port: 9080 } }\n          }\n        ]\n      }\n    }\n  }\n})\nlet reviewsService = reviews.getService()\n\nlet ratings = new solsa.apps.v1.Deployment({\n  metadata: { name: 'ratings' },\n  spec: {\n    selector: { matchLabels: { 'solsa.ibm.com/pod': 'ratings' } },\n    replicas: 1,\n    template: {\n      spec: {\n        containers: [\n          {\n            name: 'ratings',\n            image: 'istio/examples-bookinfo-ratings-v1:1.15.0',\n            env: [{ name: 'PORT', value: '9080' }],\n            ports: [{ containerPort: 9080 }],\n            livenessProbe: { tcpSocket: { port: 9080 } },\n            readinessProbe: { tcpSocket: { port: 9080 } }\n          }\n        ]\n      }\n    }\n  }\n})\nlet ratingsService = ratings.getService()\n\nlet productpage = new solsa.apps.v1.Deployment({\n  metadata: { name: 'productpage' },\n  spec: {\n    selector: { matchLabels: { 'solsa.ibm.com/pod': 'productpage' } },\n    replicas: 1,\n    template: {\n      spec: {\n        containers: [\n          {\n            name: 'productpage',\n            image: 'istio/examples-bookinfo-productpage-v1:1.15.0',\n            env: [\n              { name: 'PORT', value: '9080' },\n              { name: 'DETAILS_HOSTNAME', value: details.metadata.name },\n              { name: 'RATINGS_HOSTNAME', value: ratings.metadata.name },\n              { name: 'REVIEWS_HOSTNAME', value: reviews.metadata.name }\n            ],\n            ports: [{ containerPort: 9080 }],\n            livenessProbe: { tcpSocket: { port: 9080 } },\n            readinessProbe: { tcpSocket: { port: 9080 } }\n          }\n        ]\n      }\n    }\n  }\n})\nlet productpageService = productpage.getService()\nlet ingress = productpageService.getIngress({ vhost: 'bookinfo' })\n\nmodule.exports = new solsa.Bundle({ details, detailsService, reviews, reviewsService, ratings, ratingsService, productpage, productpageService, ingress })\n```\n\n</Tab>\n\n<Tab label=\"Generated YAML\">\n\nShown below is the output from `solsa yaml` when applied to either of the two Bookinfo specifications.\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: details\nspec:\n  ports:\n  - port: 9080\n    targetPort: 9080\n  selector:\n    solsa.ibm.com/pod: details\n  type: ClusterIP\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: productpage\nspec:\n  ports:\n  - port: 9080\n    targetPort: 9080\n  selector:\n    solsa.ibm.com/pod: productpage\n  type: ClusterIP\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: ratings\nspec:\n  ports:\n  - port: 9080\n    targetPort: 9080\n  selector:\n    solsa.ibm.com/pod: ratings\n  type: ClusterIP\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: reviews\nspec:\n  ports:\n  - port: 9080\n    targetPort: 9080\n  selector:\n    solsa.ibm.com/pod: reviews\n  type: ClusterIP\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: details\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      solsa.ibm.com/pod: details\n  template:\n    metadata:\n      labels:\n        solsa.ibm.com/pod: details\n    spec:\n      containers:\n      - env:\n        - name: PORT\n          value: \"9080\"\n        image: istio/examples-bookinfo-details-v1:1.15.0\n        livenessProbe:\n          tcpSocket:\n            port: 9080\n        name: details\n        ports:\n        - containerPort: 9080\n        readinessProbe:\n          tcpSocket:\n            port: 9080\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: productpage\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      solsa.ibm.com/pod: productpage\n  template:\n    metadata:\n      labels:\n        solsa.ibm.com/pod: productpage\n    spec:\n      containers:\n      - env:\n        - name: PORT\n          value: \"9080\"\n        - name: DETAILS_HOSTNAME\n          value: details\n        - name: RATINGS_HOSTNAME\n          value: ratings\n        - name: REVIEWS_HOSTNAME\n          value: reviews\n        image: istio/examples-bookinfo-productpage-v1:1.15.0\n        livenessProbe:\n          tcpSocket:\n            port: 9080\n        name: productpage\n        ports:\n        - containerPort: 9080\n        readinessProbe:\n          tcpSocket:\n            port: 9080\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: ratings\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      solsa.ibm.com/pod: ratings\n  template:\n    metadata:\n      labels:\n        solsa.ibm.com/pod: ratings\n    spec:\n      containers:\n      - env:\n        - name: PORT\n          value: \"9080\"\n        image: istio/examples-bookinfo-ratings-v1:1.15.0\n        livenessProbe:\n          tcpSocket:\n            port: 9080\n        name: ratings\n        ports:\n        - containerPort: 9080\n        readinessProbe:\n          tcpSocket:\n            port: 9080\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: reviews\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      solsa.ibm.com/pod: reviews\n  template:\n    metadata:\n      labels:\n        solsa.ibm.com/pod: reviews\n    spec:\n      containers:\n      - env:\n        - name: PORT\n          value: \"9080\"\n        image: istio/examples-bookinfo-reviews-v1:1.15.0\n        livenessProbe:\n          tcpSocket:\n            port: 9080\n        name: reviews\n        ports:\n        - containerPort: 9080\n        readinessProbe:\n          tcpSocket:\n            port: 9080\n---\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: productpage\nspec:\n  rules:\n  - host: bookinfo.mycluster.us-east.containers.appdomain.cloud\n    http:\n      paths:\n      - backend:\n          serviceName: productpage\n          servicePort: 9080\n        path: /\n  tls:\n  - hosts:\n    - bookinfo.mycluster.us-east.containers.appdomain.cloud\n    secretName: mycluster\n```\n\n</Tab>\n\n</Tabs>\n\n\n### Using SolSA with Kubernetes Operators\n\nThe SolSA library includes JavaScript/TypeScript bindings for every Kubernetes Operator available on\n[OperatorHub.io](https://operatorhub.io/).  These enables full IDE-support for defining applications that utilize operators to manage the life-cycles of some portions of their resources.\n\nAs an example, the tabs below show the SolSA specification and the generated YAML of a simple language translation application in which a microservice defined using SolSA's `ContainerzedService` abstraction is combined with an instance of the Watson Translator service on the IBM Public Cloud. The IBM Cloud Operator is used to instantiate the Watson Translator Service instance and make the credentials for accessing it available to the dependent microservice via a Kubernetes secret.\n\n<Tabs>\n\n<Tab label=\"SolSA\">\n\n```javascript\n\nconst path = require('path')\nconst solsa = require('solsa')\n\nfunction translator ({ name, language }) {\n  let watson = new solsa.LanguageTranslator({ name: 'watson-translator-for-' + name })\n  let translator = new solsa.ContainerizedService({ name, image: 'solsa-translator', build: path.join(__dirname, 'solsa-translator'), port: 8080 })\n  translator.env = { LANGUAGE: { value: language }, WATSON_URL: watson.getSecret('url'), WATSON_APIKEY: watson.getSecret('apikey') }\n  let ingress = translator.getIngress()\n  return new solsa.Bundle({ watson, translator, ingress })\n}\n\nmodule.exports = translator({ name: 'my-translator', language: 'en' })\n```\n\n</Tab>\n\n<Tab label=\"YAML\">\n\n```yaml\napiVersion: ibmcloud.ibm.com/v1alpha1\nkind: Service\nmetadata:\n  name: watson-translator-for-my-translator\nspec:\n  plan: lite\n  serviceClass: language-translator\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: my-translator\nspec:\n  ports:\n  - port: 8080\n    targetPort: 8080\n  selector:\n    solsa.ibm.com/pod: my-translator\n  type: ClusterIP\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-translator\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      solsa.ibm.com/pod: my-translator\n  template:\n    metadata:\n      labels:\n        solsa.ibm.com/pod: my-translator\n    spec:\n      containers:\n      - env:\n        - name: PORT\n          value: \"8080\"\n        - name: LANGUAGE\n          value: en\n        - name: WATSON_URL\n          valueFrom:\n            secretKeyRef:\n              key: url\n              name: watson-translator-for-my-translator\n        - name: WATSON_APIKEY\n          valueFrom:\n            secretKeyRef:\n              key: apikey\n              name: watson-translator-for-my-translator\n        image: docker.io/solsa/solsa-translator\n        livenessProbe:\n          tcpSocket:\n            port: 8080\n        name: my-translator\n        ports:\n        - containerPort: 8080\n        readinessProbe:\n          tcpSocket:\n            port: 8080\n---\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: my-translator\nspec:\n  rules:\n  - host: my-translator.mycluster.us-east.containers.appdomain.cloud\n    http:\n      paths:\n      - backend:\n          serviceName: my-translator\n          servicePort: 8080\n        path: /\n  tls:\n  - hosts:\n    - my-translator.mycluster.us-east.containers.appdomain.cloud\n    secretName: mycluster\n---\napiVersion: ibmcloud.ibm.com/v1alpha1\nkind: Binding\nmetadata:\n  name: watson-translator-for-my-translator\nspec:\n  serviceName: watson-translator-for-my-translator\n\n```\n</Tab>\n\n</Tabs>\n\n\n### Using SolSA with ArgoCD\n\nThe usage of ArgoCD is described in more detail in the [continuous delivery](/tools/continuous-delivery/) section of this guide. A SolSA-specified application can be used in exactly the same workflows as an application specified by a Helm chart or Kustomize tree. The only additional step is to inform ArgoCD that it should use its SolSA plugin to generate the YAML for the application. In the instructions below, we will continue using the Bookinfo sample from the [solsa-examples](https://github.com/IBM/solsa-examples) git repo. The main SolSA file for this application is `instance.js`\n\n<Tabs>\n\n<Tab label=\"ArgoCD UI\">\n\n1. Log into ArgoCD\n\n2. Click `New Application` and provide the following values:\n\n    - `application name` - dev-bookinfo\n    - `project` - default\n    - `sync-policy` - `Automatic with pruning`\n    - `repository url` - https://github.com/IBM/solsa-examples.git\n    - `revision` - HEAD\n    - `path` - examples/bookinfo\n    - `destination cluster` - https://kubernetes.default.svc\n    - `destination namespace` - dev\n\n3. Click the `EDIT AS YAML` button and add the plugin stanza shown below to the `source:` block\n```yaml\nsource:\n  plugin:\n    name: solsa\n    env:\n      - name: SOLSA_APP_MAIN\n        value: instance.js\n```\n\nFinally deploy Bookinfo by clicking the Create button.\n\n</Tab>\n\n<Tab label=\"Textual CRD\">\n\nArgoCD Applications can also be specified without using the ArgoCD UI by defining an `argoproj.io.Application` Custom Resource. In this style of management you\ncreate a `bookinfoApp.yaml` file containing the YAML shown below and then either check it into a git repo that ArgoCD is monitoring\nor directly apply it to your cluster via `kubectl apply -f bookinfoApp.yaml -n tools`. Within a few seconds, the Bookinfo application should be deployed to your `dev` namespace.\n\n```yaml\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: bookinfo\nspec:\n  project: default\n  source:\n    repoURL: 'https://github.com/IBM/solsa-examples.git'\n    path: examples/bookinfo\n    targetRevision: HEAD\n    plugin:\n      name: solsa\n      env:\n        - name: SOLSA_APP_MAIN\n          value: instance.js\n  destination:\n    server: 'https://kubernetes.default.svc'\n    namespace: dev\n  syncPolicy:\n    automated:\n      prune: true\n```\n\n</Tab>\n\n</Tabs>\n\n## More Information\n\nAdditional information on SolSA, including [a tutorial and sample applications](https://github.com/IBM/solsa-examples), is available from the [SolSA open source project](https://github.com/IBM/solsa).\n","fileAbsolutePath":"/home/runner/work/ibm-garage-developer-guide/ibm-garage-developer-guide/src/pages/tools/solsa/index.mdx"}}},"staticQueryHashes":["1364590287","2102389209","2102389209","2456312558","2746626797","2746626797","3018647132","3018647132","3037994772","3037994772","3273249464","63531786","63531786","768070550"]}