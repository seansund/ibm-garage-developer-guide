{"componentChunkName":"component---src-pages-programming-databases-index-mdx","path":"/programming/databases/","result":{"pageContext":{"frontmatter":{"title":"Cloud Databases"},"relativePagePath":"/programming/databases/index.mdx","titleType":"page","MdxNode":{"id":"96d3ffae-36ab-55da-9a3a-c5741addc92b","children":[],"parent":"7484861f-8f2f-5d0b-851c-6c61d21725b3","internal":{"content":"---\ntitle: Cloud Databases\n---\n\nimport Globals from 'gatsby-theme-carbon/src/templates/Globals';\n\n<PageDescription>\n\nUse Cloud Databases to persist application data\n\n</PageDescription>\n\n**Learning objectives:**\n\n* Learn an introduction to Cloud Databases\n* Learn about the types of Cloud Databases\n* Learn when to use the right type of Cloud Database\n* Learn how to manage IBM Cloud Databases\n* Exercise Create a Cloudant NoSQL Database\n* Exercise Integrate Database to Spring Boot Application\n* Exercise Extend Spring Boot app with CRUD methods\n\n## Introduction\n\nThe <Globals name=\"longName\" /> <Globals name=\"env\" /> provides a set of database services for persisting applications' data:\n- [Databases For PostgreSQL](https://cloud.ibm.com/docs/services/databases-for-postgresql) -- A SQL database for persisting relational data that conforms to a schema that can be queryed using SQL\n- [Cloudant](https://cloud.ibm.com/docs/services/Cloudant) -- A NoSQL database for persisting schemaless data structured as JSON documents\n- [Cloud Object Storage](https://cloud.ibm.com/docs/services/cloud-object-storage) -- For persisting binary data, especially huge sets of data\n\nMicroservices are stateless, so a cloud-native application will need servcies like these to persist their data. If a particular application does not need all of these services, only the ones it uses need to be created in the production environment.\n\nEach microservice should have its own database (zero or more), such that a particular database is only accessed by replicas of a single microservice. Yet the <Globals name=\"env\" /> only has these three database service instances for all of the microservices it hosts. Doesn't that violate best practices? No. Each database service is like a database manager, which can host multiple databases. Each microservice should have its own databases, but multiple microservices that want to use the same database technology can use databases hosted by the same database service instance. Any one database in the service is only used by a single microservice.\n\n\n= Introduction to Cloud Databases\n\nDatabase's play an important part in many cloud application. They enable applications to persist data for use between user transactions. This means its easy to store, retrieve and search for records of data that have been created or used within a Cloud native application.\n\nThe IBM Cloud offers a number of different databases that are optimized for specific purposes. This can range from storing unstructured data, to storing value key pairs into in memory caches, or managing structured data within defined data schema's.\n\nThis education will walk you through an explanation of the different types of databases offered for applications within the IBM Cloud.\n\nIt will close with an exercise to help you develop a NoSQL database and link it into a Spring Boot REST application.\n\n== Database Types\n\nSo, where do you begin in choosing a database? There are two key types we will discuss the first being  NoSQL (non-relational) and relational database management systems (RDBMS) we can start to explain the best situations to use them in your applications.\n\n=== SQL/RDBMS/Relational Databases\n\nRelational databases and related management systems (RDBMS) are more widely known and understood than their NoSQL cousins. Relational databases emerged in the 70s to store data according to a schema that allows data to be displayed as tables with rows and columns. Think of a relational database as a collection of tables, each with a schema that represents the fixed attributes and data types that the items in the table will have. RDBMSs all provide functionality for reading, creating, updating, and deleting data, typically by means of Structured Query Language (SQL) statements.\n\nThe tables in a relational database have keys associated with them, which are used to identify specific columns or rows of a table and facilitate faster access to a particular table, row, or column of interest.\n\nData integrity is of particular concern in relational databases, and RDBMS use a number of constraints to ensure that the data contained in your tables are reliable and accurate.\n\nWhile there are many relational databases, over time, these have become the most popular:\n\n- MySQL: MySQL is an open-source relational database management system (RDBMS) based on Structured Query Language (SQL). MySQL runs on virtually all platforms, including Linux, UNIX, and Windows.\n- PostgreSQL: PostgreSQL, often simply Postgres, is an object-relational database management system (ORDBMS) with an emphasis on extensibility and standards compliance.\n- DB2: DB2 is an RDBMS designed to store, analyze, and retrieve data efficiently.\n\n=== Advantages\n\n- Relational databases are well-documented and mature technologies, and RDBMSs are sold and maintained by a number of established corporations.\n- SQL standards are well-defined and commonly accepted.\n- All RDBMS are ACID-compliant, meaning their transactions are Atomic, Consistent, Isolated, and Durable\n\n=== Disadvantages\n\n- RDBMSs don't work well — or at all — with unstructured or semi-structured data due to schema and type constraints. This makes them ill-suited for large analytics or IoT event loads.\n- The tables in your relational database will not necessarily map one-to-one with an object or class representing the same data.\n- When migrating one RDBMS to another, schemas and types must generally be identical between source and destination tables for migration to work (schema constraint). For many of the same reasons, extremely complex datasets or those containing variable-length records are generally difficult to handle with an RDBMS schema.\n\n=== NoSQL/Non-Relational Databases\n\nNoSQL databases emerged as a popular alternative to relational databases as web applications became increasingly complex. NoSQL/non-relational databases can take a variety of forms. However, the critical difference between NoSQL and relational databases is that RDBMS schemas rigidly define how all data inserted into the database must be typed and composed, whereas NoSQL databases can be schema-agnostic, allowing unstructured and semi-structured data to be stored and manipulated.\n\n=== Types\n\n- Key-value stores, such as Redis , are extremely simple database management systems that store only key-value pairs and provide basic functionality for retrieving the value associated with a known key. The simplicity of key-value stores makes these database management systems particularly well-suited to embedded databases, where the stored data is not particularly complex and speed is of paramount importance.\n- Wide column stores, such as Cassandra and Scylla are schema-agnostic systems that enable users to store data in column families or tables, a single row of which can be thought of as a record — a multi-dimensional key-value store. These solutions are designed with the goal of scaling well enough to manage petabytes of data across as many as thousands of commodity servers in a massive, distributed system. Although technically schema-free, wide column stores like Scylla and Cassandra use an SQL variant called CQL for data definition and manipulation, making them straightforward to those already familiar with RDBMS.\n- Document stores, including MongoDB and Cloudant, are schema-free systems that store data in the form of JSON documents. Document stores are similar to key-value or wide column stores, but the document name is the key and the contents of the document, whatever they are, are the value. In a document store, individual records do not require a uniform structure, can contain many different value types, and can be nested. This flexibility makes them particularly well-suited to manage semi-structured data across distributed systems.\n\n- Graph databases, such as Neo4J and Datastax Enterprise Graph, represent data as a network of related nodes or objects in order to facilitate data visualizations and graph analytics. A node or object in a graph database contains free-form data that is connected by relationships and grouped according to labels. Graph-oriented database management systems (DBMS) software is designed with an emphasis on illustrating connections between data points. As a result, graph databases are typically used when analysis of the relationships between heterogeneous data points is the end goal of the system, such as in fraud prevention, advanced enterprise operations, or Facebook's original friend's graph.\n\n- Search engines, such as Elasticsearch and Solr, store data using schema-free JSON documents. They are similar to document stores, but with a greater emphasis on making your unstructured or semi-structured data easily accessible via text-based searches with strings of varying complexity.\n\n=== Advantages\n\nSince there are so many types and varied applications of NoSQL databases, it's hard to nail these down, but generally:\n\n- Schema-free data models are more flexible and easier to administer.\nNoSQL databases are generally more horizontally scalable and fault-tolerant.\n- Data can easily be distributed across different nodes. To improve  availability and/or partition tolerance, you can choose that data on some nodes be eventually consistent.\n\n=== Disadvantages\n\nThese are also dependent on the database type. Principally:\n\n- NoSQL databases are generally less widely adopted and mature than RDBMS solutions, so specific expertise is often required.\n- There is a range of formats and constraints specific to each database type.\n\n=== Which Database Is Right For You?\n\n- If your first priority is ACID transactions (Atomic, Consistent, Isolated, and Durable), consider using RDBMS.\n- If you have a massively distributed system and can settle for eventual consistency on some nodes/partitions, you might consider a wide column store such as Cassandra or Scylla.\n- If your input data is particularly heterogeneous and difficult to encapsulate according to a normalization schema, consider using a NoSQL DBMS.\n- If your goal is to scale vertically, consider an RDBMS; conversely, if you want to scale horizontally, a NoSQL DBMS may be preferable.\n\\\n= Managing IBM Cloud Databases\n\nThe [IBM Cloud](https://cloud.ibm.com) has made it very easy to manage the range of [Cloud Database](https://cloud.ibm.com/catalog?databases). The first place to look is the Catalog. It offers a dedicated section for Databases.\n\n![image](images/databases.png)\n\nThe instructor can scroll through the list and see the various types of structured and none structured databases.\n\nYou can create them easily by clicking on the tile and then selecting the plan. The best practice is to have one database per deployment environment locked down with the correct IAM (access control) rules.\n\nYou can delete the instances using the *Resource List* from the menu. You can also rename them. Most of the databases follow the resource model on the IBM Cloud. This means they can have configured credentials that can be managed in the Credentials section. They can also be bound to Cloud Foundry instances where the credentials can be accessed through the VCAP service variables. They can also be bound to a Kubernetes cluster and accesses through Kubernetes secrets.\n\n\n## Creating a Database\n\nThese steps will Create a Cloud Native NoSQL Database and populate it with data. You will then access the data through a Spring Boot micro service REST API.\n\n \t- Create the Database instance\n \t- Populate it with sample data\n\n<InlineNotification kind=\"success\">\n\nNote: If a Cloudant instance has been created already the students can skip the Create database process, if not then they need to follow these steps to create an instance.\n\n</InlineNotification>\n\n- While logged into the IBM Cloud, click on the Catalog link in the header\n\n. This will display the catalog of all the services that you can use to build cloud solutions. We are going to focus on creating a NoSQL database using the Cloudant Service. Click on Databases on the left-hand menu and you should see the list of services narrow to this view.\n\n- Select the Cloudant NoSQL DB\n    - You should see the Database creation screen,\n    - Change the name to `cloudant-<machine name>`\n    - Select `Use Both` for available authentication methods.\n    - Select the resource group you are working in.\n    - Click *Create* button to create the database instance.\n+\nThis will create a database instance that you can start working with to store your product information.\n\n- After the create is successful, you will see the Database instance Manage view.  From here you can click on the Launch button to access the database management views. We now need to configure the command line so you can upload data.\n\n- Click on the Service Credentials on the left-hand menu.\n- If there are no credentials created, click *New Credentials* button and in the dialog click *Add*. These control the access to the database. Are the credentials have been created you should see a screen similar to the one below.\n+\n![Credentials](/images/credentials.png)\n\n- .Open a command prompt and create a folder/directory called `data`\n+\n----\nmkdir data\n----\n\n. To help create test JSON data we are going to supply a template to the JSON Generator tool, this helps when creating dummy data for testing. Navigate to the following link.\n\n+\nhttps://next.json-generator.com\n\n. Replace the default template with the following template (using cut and paste). This will enable a 100 records of test data to be created to represent a products database. Click on the *Generate* button.\n\n```bash\n[\n  {\n    'repeat(1, 100)': {\n      _id: '{{objectId()}}',\n      index: '{{index()}}',\n      name: '{{lorem(2, \"words\")}}',\n      guid: '{{guid()}}',\n      delivered: '{{bool()}}',\n      price: '{{floating(1000, 4000, 2, \"$0,0.00\")}}',\n      picture: 'http://placehold.it/32x32',\n      firstname: '{{firstName()}}',\n      surname:'{{surname()}}',\n      company: '{{company().toUpperCase()}}',\n      email(tags) {\n        return `${this.firstname}.${this.surname}@${this.company}${tags.domainZone()}`.toLowerCase();\n      },\n      phone: '+1 {{phone()}}',\n      address: '{{integer(100, 999)}} {{street()}}, {{city()}}, {{state()}}, {{integer(100, 10000)}}',\n      about: '{{lorem(1, \"paragraphs\")}}',\n      created: '{{moment(this.date(new Date(2014, 0, 1), new Date())).format(\"LLLL\")}}',\n      latitude: '{{floating(-90.000001, 90)}}',\n      longitude: '{{floating(-180.000001, 180)}}',\n      ordered: '{{integer(0,999)}}'\n    }\n  }\n]\n```\n\n- Copy the generated contents on the right hand side into a file called `products-<machine name>.json` and save it into the same folder. Wrap the array with a docs statement.\n\n```bash\n{\n  \"docs\": <Add Generated array []>\n}\n```\n\n- Using a code editor create a shell script called `load.sh` that will load data into the database using a `curl` command. Use the contents from below for the script.\n\n```\n#!/bin/bash\n# load.sh\nUIDPW=\nAUTH=\"$(python -c 'import base64; print base64.urlsafe_b64encode(\"<<username>>:<<password>>\")')\"\nACURL=\"curl -s --proto '=https' -iv -g -H 'Authorization: Basic ${AUTH}'\"\nHOST=\"https://<<host>>\"\n\n# Products Data\neval ${ACURL} -X DELETE '${HOST}/<<machine name>>'\neval ${ACURL} -X PUT '${HOST}/<<machine name>>'\neval ${ACURL} -H \"Content-Type:application/json\" -d @products-<<machine name>>.json -vX POST '${HOST}/<<machine name>>/_bulk_docs'\n```\n\n- Replace the username:password fields with values from the Credentials section of the Cloudant instance in the dashboard.\n. Replace the `host` with the value from the credentials section of the dashboard. Replace `machine name` with name of your machine to create a unique database name.\n.Save the script, make it executable, and then run it.\n```\nchmod +x ./load.sh\n./load.sh\n```\n- The data from the `products-<machine name>.json` file will then be used to populate the database, to confirm this on the Dashboard click on Manage menu on the left and then Launch  button to see the Cloudant dashboard.\n- Click on the Left icon that looks like a Database and you will see the products database created.\n\n- Click on the products database itself.\n- You can see the rows of data\n- If you click on a row of data, you will see the raw NoSQL form of the data record.\n- This completes the setup of the database and populating it with data. We will be now moving onto creating a Spring Micro service that then uses this database to display Product details.\n\n## Consuming in a Spring micro service\n\nCreate a Spring Micro service and Access Cloudant NoSQL Database.\n\nIn this exercise you will:\n\n - Create a Products Micro service using Spring backend <Globals name=\"template\" />\n - Make some updates to integrate the app programmatically with the database\n - Test these changes locally\n \n. Make sure you are logged into IBM Cloud. From the menu ( menu on the top left hand side of the dashboard) select Web Apps.\n\n. You should see the main Overview screen for the IBM App Service. Navigate to the <Globals name=\"templates\" /> menu on the left-hand side. You will see a range of <Globals name=\"templates\" /> that are designed to give you a production code starting point for a variety of common patterns and frameworks for the key programming languages that are commonly used in cloud native development. Have a look through the list of <Globals name=\"templates\" /> for other types of projects you may have in the future.\n\n. Scroll down the list and find the one labelled\n`Java BFF Example with Spring\nBackend for Frontend` and click on it to select it to be created then click on `Create app`.\n\n. Within in the Create Project view, enter a sensible unique name, such as using your machine name and a numerical counter (eg. products-ms01), this is important as the Microservice will require a unique HTTP host name when its running on the platform. Once you've completed the form, click on the Create App button.\n+\nimage:createapp.png[]\n\n. This will show you the App Configuration/Details view. This view can be used to manage various aspects of your app. You will see the right-hand side has a Getting Started Quickly guide. The main body has an area where you can associate services and configure DevOps tool chains. You can also see at the top it is possible to just download the code and run it without any DevOps configuration. Using the menu in the top right, you can also rename of the project or delete it.\n\n. Now that we have created an App we need to get the code to the local machine. We could create a Dev Ops Toolchain and store the code in GIT but for this exercise we will just click on the *Download Code* button in the top right of the screen.\n\n. Unzip the downloaded file into you projects folder.\n\n. You will see that the App was created and a lot of very useful files and configuration was prepared for you to work with.\n\n..\tThe code was prepared with a manifest.yml for configuration of Cloud Foundry\n.. It has a Helm chart created for management of Kubernetes deployment\n.. It had a DevOps tool chain configuration setup for deployment to Cloud Foundry\n.. It had Maven configuration for the Spring framework and the initial bootstrap of a backend app with Java and Spring.\n\n. Open the code into your IntelJ IDE, and run it to check its startsOK.\n. Click on `Maven Tool->Plugins->spring-boot->springboot:run` Or run the the App from the run button at the top. You see the following messages at the end of the log file. This validates the app compiled successfully.\n+\n----\nThe following endpoints are available by default :-\n  OpenAPI UI    : http://localhost:8080/swagger-ui.html\n  OpenAPI json  : http://localhost:8080/swagger/api\n----\n\n. Open up a Web browser and now select the link http://localhost:8080/swagger-ui.html You should now see the Swagger API .\n\n. We now need to update the logic so we can integrate It with the Cloudant database we created earlier.\n\n. The first step is to add the credentials for accessing the database to the `application.properties` file. Open `src/main/resources/application.properties` and replace the values for the credentials and save the changes.\n\n```\ncloudant.username=<Username>\ncloudant.password=<Password>\ncloudant.url=<URL>\ncloudant.db=<machine name>\n```\n\n. Now we need to add the Cloudant Maven dependency to the `pom.xml` file. This will install the SDK required to access the Cloudant database using Java APIs.\n\n. Open `pom.xml` from the root folder and at the bottom of the dependency section underneath\nthe `spring-boot-starter-test` dependency add the following dependency configuration. Save the changes, let InteliJ install the dependency if asked.\n\n```\n<dependency>\n    <groupId>com.cloudant</groupId>\n    <artifactId>cloudant-client</artifactId>\n    <version>2.11.0</version>\n</dependency>\n```\n\n- Now we need to add the code that will read the configuration and then bookstrap the Cloudant SDK.\n\n- Create a file in `src/main/java/application` called `CloudantConfiguration.java` and add the following code.\n\n```\npackage application;\n\nimport com.cloudant.client.api.ClientBuilder;\nimport com.cloudant.client.api.CloudantClient;\nimport com.cloudant.client.api.Database;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@EnableConfigurationProperties(CloudantConfigurationProperties.class)\npublic class CloudantConfiguration {\n\t@Autowired\n\tprivate CloudantConfigurationProperties config;\n\n\t@Bean\n\tpublic CloudantClient client() {\n\t\tClientBuilder builder = ClientBuilder\n\t\t\t.url(config.getUrl())\n\t\t\t.username(config.getUsername())\n\t\t\t.password(config.getPassword());\n\t\treturn builder.build();\n\t}\n\n\t@Bean\n\tpublic Database database(CloudantClient client) {\n\t\tDatabase db = client.database(config.getDb(), true);\n\t\treturn db;\n\t}\n}\n```\n\n. Create another new file in `src/main/java/application` called `CloudantConfigurationProperties.java` and add the following contents, then save it.\n\n```\npackage application;\n\nimport java.net.URL;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\n@ConfigurationProperties(prefix=\"cloudant\")\npublic class CloudantConfigurationProperties {\n\n\tprivate URL url;\n\n\tprivate String username;\n\n\tprivate String password;\n\n\tprivate String db;\n\n\tpublic void setUrl(URL url) {\n\t\tthis.url = url;\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\n\tpublic void setPassword(String password) {\n\t\tthis.password = password;\n\t}\n\n\tpublic void setDb(String db) {\n\t\tthis.db = db;\n\t}\n\n\tpublic URL getUrl() {\n\t\treturn this.url;\n\t}\n\n\tpublic String getUsername() {\n\t\treturn this.username;\n\t}\n\n\tpublic String getPassword() {\n\t\treturn this.password;\n\t}\n\n\tpublic String getDb() {\n\t\treturn this.db;\n\t}\n\n}\n```\n\n.- With the Database configuration setup we now need to update the Model. Replace the contents of the `src/main/java/application/model/Product.java` with an updated model that maps to the data in the Database. Save the file once contents has been replaced.\n\n```\npackage application.model;\n\nimport java.util.Objects;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport io.swagger.annotations.ApiModel;\nimport io.swagger.annotations.ApiModelProperty;\nimport org.springframework.validation.annotation.Validated;\nimport javax.validation.Valid;\nimport javax.validation.constraints.*;\n\n/**\n * A product object\n */\n@ApiModel(description = \"A product object\")\n@Validated\n@javax.annotation.Generated(value = \"com.ibm.mobile.sdkgen.platform.JavaSpringBindingsConfig\", date = \"2019-01-16T16:53:58.923Z\")\n\npublic class Product   {\n\n  @JsonProperty(\"_id\")\n  private String _id = null;\n\n  @JsonProperty(\"name\")\n  private String name = null;\n\n  @JsonProperty(\"firstname\")\n  private String firstname = null;\n  @JsonProperty(\"surname\")\n  private String surname = null;\n\n  @JsonProperty(\"guid\")\n  private String guid = null;\n  @JsonProperty(\"delivered\")\n  private boolean delivered = false;\n  @JsonProperty(\"price\")\n  private String price = null;\n  @JsonProperty(\"picture\")\n  private String picture = null;\n  @JsonProperty(\"ordered\")\n  private int ordered = 0;\n  @JsonProperty(\"email\")\n  private String email = null;\n  @JsonProperty(\"phone\")\n  private String phone = null;\n  @JsonProperty(\"address\")\n  private String address = null;\n  @JsonProperty(\"about\")\n  private String about = null;\n  @JsonProperty(\"created\")\n  private String created = null;\n  @JsonProperty(\"latitude\")\n  private String latitude = null;\n\n  public String getCompany() {\n    return company;\n  }\n\n  public void setCompany(String company) {\n    this.company = company;\n  }\n\n  @JsonProperty(\"longitude\")\n  private String longitude = null;\n  @JsonProperty(\"company\")\n  private String company = null;\n\n\n  public Product id(String id) {\n    this._id = id;\n    return this;\n  }\n\n  /**\n   * Get identifier\n   * @return identifier\n   **/\n  @ApiModelProperty(required = true, value = \"\")\n  @NotNull\n\n  public String get_id() {\n    return _id;\n  }\n\n  public void set_id(String id) {\n    this._id = id;\n  }\n\n  public Product name(String name) {\n    this.name = name;\n    return this;\n  }\n\n  public String getGuid() {\n    return guid;\n  }\n\n  public void setGuid(String guid) {\n    this.guid = guid;\n  }\n\n  public boolean isDelivered() {\n    return delivered;\n  }\n\n  public void setDelivered(boolean delivered) {\n    this.delivered = delivered;\n  }\n\n  public String getPrice() {\n    return price;\n  }\n\n  public void setPrice(String price) {\n    this.price = price;\n  }\n\n  public String getPicture() {\n    return picture;\n  }\n\n  public void setPicture(String picture) {\n    this.picture = picture;\n  }\n\n  public int getOrdered() {\n    return ordered;\n  }\n\n  public void setOrdered(int ordered) {\n    this.ordered = ordered;\n  }\n\n  public String getEmail() {\n    return email;\n  }\n\n  public void setEmail(String email) {\n    this.email = email;\n  }\n\n  public String getPhone() {\n    return phone;\n  }\n\n  public void setPhone(String phone) {\n    this.phone = phone;\n  }\n\n  public String getAddress() {\n    return address;\n  }\n\n  public void setAddress(String address) {\n    this.address = address;\n  }\n\n  public String getAbout() {\n    return about;\n  }\n\n  public void setAbout(String about) {\n    this.about = about;\n  }\n\n  public String getCreated() {\n    return created;\n  }\n\n  public void setCreated(String created) {\n    this.created = created;\n  }\n\n  public String getLatitude() {\n    return latitude;\n  }\n\n  public void setLatitude(String latitude) {\n    this.latitude = latitude;\n  }\n\n  public String getLongitude() {\n    return longitude;\n  }\n\n  public void setLongitude(String longitude) {\n    this.longitude = longitude;\n  }\n\n  public String getFirstname() {\n    return firstname;\n  }\n\n  public void setFirstname(String firstname) {\n    this.firstname = firstname;\n  }\n\n  public String getSurname() {\n    return surname;\n  }\n\n  public void setSurname(String surname) {\n    this.surname = surname;\n  }\n\n  /**\n   * Get name\n   * @return name\n   **/\n  @ApiModelProperty(required = true, value = \"\")\n  @NotNull\n\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    Product product = (Product) o;\n    return Objects.equals(this._id, product._id) &&\n            Objects.equals(this.name, product.name);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(_id, name);\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class Product {\\n\");\n\n    sb.append(\"    identifier: \").append(toIndentedString(_id)).append(\"\\n\");\n    sb.append(\"    name: \").append(toIndentedString(name)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n}\n```\n\n- Using the <Globals name=\"template\" /> it helps as it has already defined a `Products` API using Spring Boot. We can now extend this with the Cloudant API calls to access the contents of the database.\n\n- Open `src/main/java/application/ProductsApiBinding.java`, add the following `import`.\n\n```\nimport com.cloudant.client.api.Database;\nimport java.io.IOException;\n```\n. Add the following attribute to the class so we can access the database instance object.\n\n```\n@Autowired\nprivate Database db;\n----\n. Final step is to add the code to `getAll` this retrieves the stored documents in the database. Replace the contents of the `getAll` method with the following code.\n```\n    ApiResponseMessage ApiRm = null;\n    try {\n        List<Product> allDocs = db.getAllDocsRequestBuilder().includeDocs(true).build().getResponse().getDocsAs(Product.class);\n        ApiRm = new ApiResponseMessage<>(HttpStatus.FOUND, \"\", allDocs);\n\n    } catch (IOException e) {\n        ApiRm = new ApiResponseMessage<>(HttpStatus.NOT_FOUND, \"\", null);\n    }\n\n    return ApiRm;\n```\n. You can see the code using the `db` instance to call Cloudant Couch DB APIs and return a List of documents, this is then wrapped into a `ApiResponseMessage` so a consistent handling of HTTP response messages can be achieved. Save any changes and rerun the micro service.\n\n. Open the Swagger UI endpoint listed in the console logs. You should see a Swagger API looking similar to the screen shot below.\n+\n\n![Swagger](/images/swaggerapi.png)\n\n. Expand the *GET* `/products` API endpoint and select *Try It* The response body should now display an array of all the documents stored in the NoSQL database.\n+\n```\n[\n  {\n    \"_id\": \"5c3f915101ca439a6631445f\",\n    \"name\": \"consectetur anim\",\n    \"firstname\": \"Anna\",\n    \"surname\": \"Landry\",\n    \"guid\": \"df52ff12-b678-4a80-a3cf-933affd0e723\",\n    \"delivered\": true,\n    \"price\": \"$3,555.02\",\n    \"picture\": \"http://placehold.it/32x32\",\n    \"ordered\": 938,\n    \"email\": \"anna.landry@niquent.co.uk\",\n    \"phone\": \"+1 (993) 468-2139\",\n    \"address\": \"510 Fairview Place, Vowinckel, Delaware, 3513\",\n    \"about\": \"Reprehenderit id irure minim sit. Minim tempor laborum sit fugiat exercitation do Lorem cupidatat id. Enim laboris occaecat aute id voluptate mollit sit dolor. Ex occaecat labore sit nulla proident ipsum incididunt nulla officia fugiat voluptate tempor elit. Culpa amet enim voluptate veniam qui Lorem elit incididunt sint laborum id laborum. Anim occaecat commodo culpa quis aliquip dolore. Veniam nulla non et culpa.\",\n    \"created\": \"Wednesday, December 21, 2016 9:03 AM\",\n    \"latitude\": \"-34.934096\",\n    \"longitude\": \"-173.018863\",\n    \"company\": \"NIQUENT\"\n  },\n```\n. Using a NoSQL database allows for lots of flexibility for the document format and they have a lot of rich APIs.\n\n. Congratulations ! In this short exercise, you have created and deployed a Java Spring microservice and integrated to an IBM Cloud Cloudant database instance.\n\n### References\n\n-  https://console.bluemix.net/docs/services/Cloudant/getting-started.html#getting-started-with-cloudant\n- http://spring.io/projects/spring-boot\n- https://cloud.ibm.com/\n- https://cloud.ibm.com/catalog?category=databases\n- https://github.com/cloudant/java-cloudant\n","type":"Mdx","contentDigest":"077c07b899ca13daf9e1563d08e0e395","counter":995,"owner":"gatsby-plugin-mdx"},"frontmatter":{"title":"Cloud Databases"},"exports":{},"rawBody":"---\ntitle: Cloud Databases\n---\n\nimport Globals from 'gatsby-theme-carbon/src/templates/Globals';\n\n<PageDescription>\n\nUse Cloud Databases to persist application data\n\n</PageDescription>\n\n**Learning objectives:**\n\n* Learn an introduction to Cloud Databases\n* Learn about the types of Cloud Databases\n* Learn when to use the right type of Cloud Database\n* Learn how to manage IBM Cloud Databases\n* Exercise Create a Cloudant NoSQL Database\n* Exercise Integrate Database to Spring Boot Application\n* Exercise Extend Spring Boot app with CRUD methods\n\n## Introduction\n\nThe <Globals name=\"longName\" /> <Globals name=\"env\" /> provides a set of database services for persisting applications' data:\n- [Databases For PostgreSQL](https://cloud.ibm.com/docs/services/databases-for-postgresql) -- A SQL database for persisting relational data that conforms to a schema that can be queryed using SQL\n- [Cloudant](https://cloud.ibm.com/docs/services/Cloudant) -- A NoSQL database for persisting schemaless data structured as JSON documents\n- [Cloud Object Storage](https://cloud.ibm.com/docs/services/cloud-object-storage) -- For persisting binary data, especially huge sets of data\n\nMicroservices are stateless, so a cloud-native application will need servcies like these to persist their data. If a particular application does not need all of these services, only the ones it uses need to be created in the production environment.\n\nEach microservice should have its own database (zero or more), such that a particular database is only accessed by replicas of a single microservice. Yet the <Globals name=\"env\" /> only has these three database service instances for all of the microservices it hosts. Doesn't that violate best practices? No. Each database service is like a database manager, which can host multiple databases. Each microservice should have its own databases, but multiple microservices that want to use the same database technology can use databases hosted by the same database service instance. Any one database in the service is only used by a single microservice.\n\n\n= Introduction to Cloud Databases\n\nDatabase's play an important part in many cloud application. They enable applications to persist data for use between user transactions. This means its easy to store, retrieve and search for records of data that have been created or used within a Cloud native application.\n\nThe IBM Cloud offers a number of different databases that are optimized for specific purposes. This can range from storing unstructured data, to storing value key pairs into in memory caches, or managing structured data within defined data schema's.\n\nThis education will walk you through an explanation of the different types of databases offered for applications within the IBM Cloud.\n\nIt will close with an exercise to help you develop a NoSQL database and link it into a Spring Boot REST application.\n\n== Database Types\n\nSo, where do you begin in choosing a database? There are two key types we will discuss the first being  NoSQL (non-relational) and relational database management systems (RDBMS) we can start to explain the best situations to use them in your applications.\n\n=== SQL/RDBMS/Relational Databases\n\nRelational databases and related management systems (RDBMS) are more widely known and understood than their NoSQL cousins. Relational databases emerged in the 70s to store data according to a schema that allows data to be displayed as tables with rows and columns. Think of a relational database as a collection of tables, each with a schema that represents the fixed attributes and data types that the items in the table will have. RDBMSs all provide functionality for reading, creating, updating, and deleting data, typically by means of Structured Query Language (SQL) statements.\n\nThe tables in a relational database have keys associated with them, which are used to identify specific columns or rows of a table and facilitate faster access to a particular table, row, or column of interest.\n\nData integrity is of particular concern in relational databases, and RDBMS use a number of constraints to ensure that the data contained in your tables are reliable and accurate.\n\nWhile there are many relational databases, over time, these have become the most popular:\n\n- MySQL: MySQL is an open-source relational database management system (RDBMS) based on Structured Query Language (SQL). MySQL runs on virtually all platforms, including Linux, UNIX, and Windows.\n- PostgreSQL: PostgreSQL, often simply Postgres, is an object-relational database management system (ORDBMS) with an emphasis on extensibility and standards compliance.\n- DB2: DB2 is an RDBMS designed to store, analyze, and retrieve data efficiently.\n\n=== Advantages\n\n- Relational databases are well-documented and mature technologies, and RDBMSs are sold and maintained by a number of established corporations.\n- SQL standards are well-defined and commonly accepted.\n- All RDBMS are ACID-compliant, meaning their transactions are Atomic, Consistent, Isolated, and Durable\n\n=== Disadvantages\n\n- RDBMSs don't work well — or at all — with unstructured or semi-structured data due to schema and type constraints. This makes them ill-suited for large analytics or IoT event loads.\n- The tables in your relational database will not necessarily map one-to-one with an object or class representing the same data.\n- When migrating one RDBMS to another, schemas and types must generally be identical between source and destination tables for migration to work (schema constraint). For many of the same reasons, extremely complex datasets or those containing variable-length records are generally difficult to handle with an RDBMS schema.\n\n=== NoSQL/Non-Relational Databases\n\nNoSQL databases emerged as a popular alternative to relational databases as web applications became increasingly complex. NoSQL/non-relational databases can take a variety of forms. However, the critical difference between NoSQL and relational databases is that RDBMS schemas rigidly define how all data inserted into the database must be typed and composed, whereas NoSQL databases can be schema-agnostic, allowing unstructured and semi-structured data to be stored and manipulated.\n\n=== Types\n\n- Key-value stores, such as Redis , are extremely simple database management systems that store only key-value pairs and provide basic functionality for retrieving the value associated with a known key. The simplicity of key-value stores makes these database management systems particularly well-suited to embedded databases, where the stored data is not particularly complex and speed is of paramount importance.\n- Wide column stores, such as Cassandra and Scylla are schema-agnostic systems that enable users to store data in column families or tables, a single row of which can be thought of as a record — a multi-dimensional key-value store. These solutions are designed with the goal of scaling well enough to manage petabytes of data across as many as thousands of commodity servers in a massive, distributed system. Although technically schema-free, wide column stores like Scylla and Cassandra use an SQL variant called CQL for data definition and manipulation, making them straightforward to those already familiar with RDBMS.\n- Document stores, including MongoDB and Cloudant, are schema-free systems that store data in the form of JSON documents. Document stores are similar to key-value or wide column stores, but the document name is the key and the contents of the document, whatever they are, are the value. In a document store, individual records do not require a uniform structure, can contain many different value types, and can be nested. This flexibility makes them particularly well-suited to manage semi-structured data across distributed systems.\n\n- Graph databases, such as Neo4J and Datastax Enterprise Graph, represent data as a network of related nodes or objects in order to facilitate data visualizations and graph analytics. A node or object in a graph database contains free-form data that is connected by relationships and grouped according to labels. Graph-oriented database management systems (DBMS) software is designed with an emphasis on illustrating connections between data points. As a result, graph databases are typically used when analysis of the relationships between heterogeneous data points is the end goal of the system, such as in fraud prevention, advanced enterprise operations, or Facebook's original friend's graph.\n\n- Search engines, such as Elasticsearch and Solr, store data using schema-free JSON documents. They are similar to document stores, but with a greater emphasis on making your unstructured or semi-structured data easily accessible via text-based searches with strings of varying complexity.\n\n=== Advantages\n\nSince there are so many types and varied applications of NoSQL databases, it's hard to nail these down, but generally:\n\n- Schema-free data models are more flexible and easier to administer.\nNoSQL databases are generally more horizontally scalable and fault-tolerant.\n- Data can easily be distributed across different nodes. To improve  availability and/or partition tolerance, you can choose that data on some nodes be eventually consistent.\n\n=== Disadvantages\n\nThese are also dependent on the database type. Principally:\n\n- NoSQL databases are generally less widely adopted and mature than RDBMS solutions, so specific expertise is often required.\n- There is a range of formats and constraints specific to each database type.\n\n=== Which Database Is Right For You?\n\n- If your first priority is ACID transactions (Atomic, Consistent, Isolated, and Durable), consider using RDBMS.\n- If you have a massively distributed system and can settle for eventual consistency on some nodes/partitions, you might consider a wide column store such as Cassandra or Scylla.\n- If your input data is particularly heterogeneous and difficult to encapsulate according to a normalization schema, consider using a NoSQL DBMS.\n- If your goal is to scale vertically, consider an RDBMS; conversely, if you want to scale horizontally, a NoSQL DBMS may be preferable.\n\\\n= Managing IBM Cloud Databases\n\nThe [IBM Cloud](https://cloud.ibm.com) has made it very easy to manage the range of [Cloud Database](https://cloud.ibm.com/catalog?databases). The first place to look is the Catalog. It offers a dedicated section for Databases.\n\n![image](images/databases.png)\n\nThe instructor can scroll through the list and see the various types of structured and none structured databases.\n\nYou can create them easily by clicking on the tile and then selecting the plan. The best practice is to have one database per deployment environment locked down with the correct IAM (access control) rules.\n\nYou can delete the instances using the *Resource List* from the menu. You can also rename them. Most of the databases follow the resource model on the IBM Cloud. This means they can have configured credentials that can be managed in the Credentials section. They can also be bound to Cloud Foundry instances where the credentials can be accessed through the VCAP service variables. They can also be bound to a Kubernetes cluster and accesses through Kubernetes secrets.\n\n\n## Creating a Database\n\nThese steps will Create a Cloud Native NoSQL Database and populate it with data. You will then access the data through a Spring Boot micro service REST API.\n\n \t- Create the Database instance\n \t- Populate it with sample data\n\n<InlineNotification kind=\"success\">\n\nNote: If a Cloudant instance has been created already the students can skip the Create database process, if not then they need to follow these steps to create an instance.\n\n</InlineNotification>\n\n- While logged into the IBM Cloud, click on the Catalog link in the header\n\n. This will display the catalog of all the services that you can use to build cloud solutions. We are going to focus on creating a NoSQL database using the Cloudant Service. Click on Databases on the left-hand menu and you should see the list of services narrow to this view.\n\n- Select the Cloudant NoSQL DB\n    - You should see the Database creation screen,\n    - Change the name to `cloudant-<machine name>`\n    - Select `Use Both` for available authentication methods.\n    - Select the resource group you are working in.\n    - Click *Create* button to create the database instance.\n+\nThis will create a database instance that you can start working with to store your product information.\n\n- After the create is successful, you will see the Database instance Manage view.  From here you can click on the Launch button to access the database management views. We now need to configure the command line so you can upload data.\n\n- Click on the Service Credentials on the left-hand menu.\n- If there are no credentials created, click *New Credentials* button and in the dialog click *Add*. These control the access to the database. Are the credentials have been created you should see a screen similar to the one below.\n+\n![Credentials](/images/credentials.png)\n\n- .Open a command prompt and create a folder/directory called `data`\n+\n----\nmkdir data\n----\n\n. To help create test JSON data we are going to supply a template to the JSON Generator tool, this helps when creating dummy data for testing. Navigate to the following link.\n\n+\nhttps://next.json-generator.com\n\n. Replace the default template with the following template (using cut and paste). This will enable a 100 records of test data to be created to represent a products database. Click on the *Generate* button.\n\n```bash\n[\n  {\n    'repeat(1, 100)': {\n      _id: '{{objectId()}}',\n      index: '{{index()}}',\n      name: '{{lorem(2, \"words\")}}',\n      guid: '{{guid()}}',\n      delivered: '{{bool()}}',\n      price: '{{floating(1000, 4000, 2, \"$0,0.00\")}}',\n      picture: 'http://placehold.it/32x32',\n      firstname: '{{firstName()}}',\n      surname:'{{surname()}}',\n      company: '{{company().toUpperCase()}}',\n      email(tags) {\n        return `${this.firstname}.${this.surname}@${this.company}${tags.domainZone()}`.toLowerCase();\n      },\n      phone: '+1 {{phone()}}',\n      address: '{{integer(100, 999)}} {{street()}}, {{city()}}, {{state()}}, {{integer(100, 10000)}}',\n      about: '{{lorem(1, \"paragraphs\")}}',\n      created: '{{moment(this.date(new Date(2014, 0, 1), new Date())).format(\"LLLL\")}}',\n      latitude: '{{floating(-90.000001, 90)}}',\n      longitude: '{{floating(-180.000001, 180)}}',\n      ordered: '{{integer(0,999)}}'\n    }\n  }\n]\n```\n\n- Copy the generated contents on the right hand side into a file called `products-<machine name>.json` and save it into the same folder. Wrap the array with a docs statement.\n\n```bash\n{\n  \"docs\": <Add Generated array []>\n}\n```\n\n- Using a code editor create a shell script called `load.sh` that will load data into the database using a `curl` command. Use the contents from below for the script.\n\n```\n#!/bin/bash\n# load.sh\nUIDPW=\nAUTH=\"$(python -c 'import base64; print base64.urlsafe_b64encode(\"<<username>>:<<password>>\")')\"\nACURL=\"curl -s --proto '=https' -iv -g -H 'Authorization: Basic ${AUTH}'\"\nHOST=\"https://<<host>>\"\n\n# Products Data\neval ${ACURL} -X DELETE '${HOST}/<<machine name>>'\neval ${ACURL} -X PUT '${HOST}/<<machine name>>'\neval ${ACURL} -H \"Content-Type:application/json\" -d @products-<<machine name>>.json -vX POST '${HOST}/<<machine name>>/_bulk_docs'\n```\n\n- Replace the username:password fields with values from the Credentials section of the Cloudant instance in the dashboard.\n. Replace the `host` with the value from the credentials section of the dashboard. Replace `machine name` with name of your machine to create a unique database name.\n.Save the script, make it executable, and then run it.\n```\nchmod +x ./load.sh\n./load.sh\n```\n- The data from the `products-<machine name>.json` file will then be used to populate the database, to confirm this on the Dashboard click on Manage menu on the left and then Launch  button to see the Cloudant dashboard.\n- Click on the Left icon that looks like a Database and you will see the products database created.\n\n- Click on the products database itself.\n- You can see the rows of data\n- If you click on a row of data, you will see the raw NoSQL form of the data record.\n- This completes the setup of the database and populating it with data. We will be now moving onto creating a Spring Micro service that then uses this database to display Product details.\n\n## Consuming in a Spring micro service\n\nCreate a Spring Micro service and Access Cloudant NoSQL Database.\n\nIn this exercise you will:\n\n - Create a Products Micro service using Spring backend <Globals name=\"template\" />\n - Make some updates to integrate the app programmatically with the database\n - Test these changes locally\n \n. Make sure you are logged into IBM Cloud. From the menu ( menu on the top left hand side of the dashboard) select Web Apps.\n\n. You should see the main Overview screen for the IBM App Service. Navigate to the <Globals name=\"templates\" /> menu on the left-hand side. You will see a range of <Globals name=\"templates\" /> that are designed to give you a production code starting point for a variety of common patterns and frameworks for the key programming languages that are commonly used in cloud native development. Have a look through the list of <Globals name=\"templates\" /> for other types of projects you may have in the future.\n\n. Scroll down the list and find the one labelled\n`Java BFF Example with Spring\nBackend for Frontend` and click on it to select it to be created then click on `Create app`.\n\n. Within in the Create Project view, enter a sensible unique name, such as using your machine name and a numerical counter (eg. products-ms01), this is important as the Microservice will require a unique HTTP host name when its running on the platform. Once you've completed the form, click on the Create App button.\n+\nimage:createapp.png[]\n\n. This will show you the App Configuration/Details view. This view can be used to manage various aspects of your app. You will see the right-hand side has a Getting Started Quickly guide. The main body has an area where you can associate services and configure DevOps tool chains. You can also see at the top it is possible to just download the code and run it without any DevOps configuration. Using the menu in the top right, you can also rename of the project or delete it.\n\n. Now that we have created an App we need to get the code to the local machine. We could create a Dev Ops Toolchain and store the code in GIT but for this exercise we will just click on the *Download Code* button in the top right of the screen.\n\n. Unzip the downloaded file into you projects folder.\n\n. You will see that the App was created and a lot of very useful files and configuration was prepared for you to work with.\n\n..\tThe code was prepared with a manifest.yml for configuration of Cloud Foundry\n.. It has a Helm chart created for management of Kubernetes deployment\n.. It had a DevOps tool chain configuration setup for deployment to Cloud Foundry\n.. It had Maven configuration for the Spring framework and the initial bootstrap of a backend app with Java and Spring.\n\n. Open the code into your IntelJ IDE, and run it to check its startsOK.\n. Click on `Maven Tool->Plugins->spring-boot->springboot:run` Or run the the App from the run button at the top. You see the following messages at the end of the log file. This validates the app compiled successfully.\n+\n----\nThe following endpoints are available by default :-\n  OpenAPI UI    : http://localhost:8080/swagger-ui.html\n  OpenAPI json  : http://localhost:8080/swagger/api\n----\n\n. Open up a Web browser and now select the link http://localhost:8080/swagger-ui.html You should now see the Swagger API .\n\n. We now need to update the logic so we can integrate It with the Cloudant database we created earlier.\n\n. The first step is to add the credentials for accessing the database to the `application.properties` file. Open `src/main/resources/application.properties` and replace the values for the credentials and save the changes.\n\n```\ncloudant.username=<Username>\ncloudant.password=<Password>\ncloudant.url=<URL>\ncloudant.db=<machine name>\n```\n\n. Now we need to add the Cloudant Maven dependency to the `pom.xml` file. This will install the SDK required to access the Cloudant database using Java APIs.\n\n. Open `pom.xml` from the root folder and at the bottom of the dependency section underneath\nthe `spring-boot-starter-test` dependency add the following dependency configuration. Save the changes, let InteliJ install the dependency if asked.\n\n```\n<dependency>\n    <groupId>com.cloudant</groupId>\n    <artifactId>cloudant-client</artifactId>\n    <version>2.11.0</version>\n</dependency>\n```\n\n- Now we need to add the code that will read the configuration and then bookstrap the Cloudant SDK.\n\n- Create a file in `src/main/java/application` called `CloudantConfiguration.java` and add the following code.\n\n```\npackage application;\n\nimport com.cloudant.client.api.ClientBuilder;\nimport com.cloudant.client.api.CloudantClient;\nimport com.cloudant.client.api.Database;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@EnableConfigurationProperties(CloudantConfigurationProperties.class)\npublic class CloudantConfiguration {\n\t@Autowired\n\tprivate CloudantConfigurationProperties config;\n\n\t@Bean\n\tpublic CloudantClient client() {\n\t\tClientBuilder builder = ClientBuilder\n\t\t\t.url(config.getUrl())\n\t\t\t.username(config.getUsername())\n\t\t\t.password(config.getPassword());\n\t\treturn builder.build();\n\t}\n\n\t@Bean\n\tpublic Database database(CloudantClient client) {\n\t\tDatabase db = client.database(config.getDb(), true);\n\t\treturn db;\n\t}\n}\n```\n\n. Create another new file in `src/main/java/application` called `CloudantConfigurationProperties.java` and add the following contents, then save it.\n\n```\npackage application;\n\nimport java.net.URL;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\n@ConfigurationProperties(prefix=\"cloudant\")\npublic class CloudantConfigurationProperties {\n\n\tprivate URL url;\n\n\tprivate String username;\n\n\tprivate String password;\n\n\tprivate String db;\n\n\tpublic void setUrl(URL url) {\n\t\tthis.url = url;\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\n\tpublic void setPassword(String password) {\n\t\tthis.password = password;\n\t}\n\n\tpublic void setDb(String db) {\n\t\tthis.db = db;\n\t}\n\n\tpublic URL getUrl() {\n\t\treturn this.url;\n\t}\n\n\tpublic String getUsername() {\n\t\treturn this.username;\n\t}\n\n\tpublic String getPassword() {\n\t\treturn this.password;\n\t}\n\n\tpublic String getDb() {\n\t\treturn this.db;\n\t}\n\n}\n```\n\n.- With the Database configuration setup we now need to update the Model. Replace the contents of the `src/main/java/application/model/Product.java` with an updated model that maps to the data in the Database. Save the file once contents has been replaced.\n\n```\npackage application.model;\n\nimport java.util.Objects;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport io.swagger.annotations.ApiModel;\nimport io.swagger.annotations.ApiModelProperty;\nimport org.springframework.validation.annotation.Validated;\nimport javax.validation.Valid;\nimport javax.validation.constraints.*;\n\n/**\n * A product object\n */\n@ApiModel(description = \"A product object\")\n@Validated\n@javax.annotation.Generated(value = \"com.ibm.mobile.sdkgen.platform.JavaSpringBindingsConfig\", date = \"2019-01-16T16:53:58.923Z\")\n\npublic class Product   {\n\n  @JsonProperty(\"_id\")\n  private String _id = null;\n\n  @JsonProperty(\"name\")\n  private String name = null;\n\n  @JsonProperty(\"firstname\")\n  private String firstname = null;\n  @JsonProperty(\"surname\")\n  private String surname = null;\n\n  @JsonProperty(\"guid\")\n  private String guid = null;\n  @JsonProperty(\"delivered\")\n  private boolean delivered = false;\n  @JsonProperty(\"price\")\n  private String price = null;\n  @JsonProperty(\"picture\")\n  private String picture = null;\n  @JsonProperty(\"ordered\")\n  private int ordered = 0;\n  @JsonProperty(\"email\")\n  private String email = null;\n  @JsonProperty(\"phone\")\n  private String phone = null;\n  @JsonProperty(\"address\")\n  private String address = null;\n  @JsonProperty(\"about\")\n  private String about = null;\n  @JsonProperty(\"created\")\n  private String created = null;\n  @JsonProperty(\"latitude\")\n  private String latitude = null;\n\n  public String getCompany() {\n    return company;\n  }\n\n  public void setCompany(String company) {\n    this.company = company;\n  }\n\n  @JsonProperty(\"longitude\")\n  private String longitude = null;\n  @JsonProperty(\"company\")\n  private String company = null;\n\n\n  public Product id(String id) {\n    this._id = id;\n    return this;\n  }\n\n  /**\n   * Get identifier\n   * @return identifier\n   **/\n  @ApiModelProperty(required = true, value = \"\")\n  @NotNull\n\n  public String get_id() {\n    return _id;\n  }\n\n  public void set_id(String id) {\n    this._id = id;\n  }\n\n  public Product name(String name) {\n    this.name = name;\n    return this;\n  }\n\n  public String getGuid() {\n    return guid;\n  }\n\n  public void setGuid(String guid) {\n    this.guid = guid;\n  }\n\n  public boolean isDelivered() {\n    return delivered;\n  }\n\n  public void setDelivered(boolean delivered) {\n    this.delivered = delivered;\n  }\n\n  public String getPrice() {\n    return price;\n  }\n\n  public void setPrice(String price) {\n    this.price = price;\n  }\n\n  public String getPicture() {\n    return picture;\n  }\n\n  public void setPicture(String picture) {\n    this.picture = picture;\n  }\n\n  public int getOrdered() {\n    return ordered;\n  }\n\n  public void setOrdered(int ordered) {\n    this.ordered = ordered;\n  }\n\n  public String getEmail() {\n    return email;\n  }\n\n  public void setEmail(String email) {\n    this.email = email;\n  }\n\n  public String getPhone() {\n    return phone;\n  }\n\n  public void setPhone(String phone) {\n    this.phone = phone;\n  }\n\n  public String getAddress() {\n    return address;\n  }\n\n  public void setAddress(String address) {\n    this.address = address;\n  }\n\n  public String getAbout() {\n    return about;\n  }\n\n  public void setAbout(String about) {\n    this.about = about;\n  }\n\n  public String getCreated() {\n    return created;\n  }\n\n  public void setCreated(String created) {\n    this.created = created;\n  }\n\n  public String getLatitude() {\n    return latitude;\n  }\n\n  public void setLatitude(String latitude) {\n    this.latitude = latitude;\n  }\n\n  public String getLongitude() {\n    return longitude;\n  }\n\n  public void setLongitude(String longitude) {\n    this.longitude = longitude;\n  }\n\n  public String getFirstname() {\n    return firstname;\n  }\n\n  public void setFirstname(String firstname) {\n    this.firstname = firstname;\n  }\n\n  public String getSurname() {\n    return surname;\n  }\n\n  public void setSurname(String surname) {\n    this.surname = surname;\n  }\n\n  /**\n   * Get name\n   * @return name\n   **/\n  @ApiModelProperty(required = true, value = \"\")\n  @NotNull\n\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    Product product = (Product) o;\n    return Objects.equals(this._id, product._id) &&\n            Objects.equals(this.name, product.name);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(_id, name);\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class Product {\\n\");\n\n    sb.append(\"    identifier: \").append(toIndentedString(_id)).append(\"\\n\");\n    sb.append(\"    name: \").append(toIndentedString(name)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n}\n```\n\n- Using the <Globals name=\"template\" /> it helps as it has already defined a `Products` API using Spring Boot. We can now extend this with the Cloudant API calls to access the contents of the database.\n\n- Open `src/main/java/application/ProductsApiBinding.java`, add the following `import`.\n\n```\nimport com.cloudant.client.api.Database;\nimport java.io.IOException;\n```\n. Add the following attribute to the class so we can access the database instance object.\n\n```\n@Autowired\nprivate Database db;\n----\n. Final step is to add the code to `getAll` this retrieves the stored documents in the database. Replace the contents of the `getAll` method with the following code.\n```\n    ApiResponseMessage ApiRm = null;\n    try {\n        List<Product> allDocs = db.getAllDocsRequestBuilder().includeDocs(true).build().getResponse().getDocsAs(Product.class);\n        ApiRm = new ApiResponseMessage<>(HttpStatus.FOUND, \"\", allDocs);\n\n    } catch (IOException e) {\n        ApiRm = new ApiResponseMessage<>(HttpStatus.NOT_FOUND, \"\", null);\n    }\n\n    return ApiRm;\n```\n. You can see the code using the `db` instance to call Cloudant Couch DB APIs and return a List of documents, this is then wrapped into a `ApiResponseMessage` so a consistent handling of HTTP response messages can be achieved. Save any changes and rerun the micro service.\n\n. Open the Swagger UI endpoint listed in the console logs. You should see a Swagger API looking similar to the screen shot below.\n+\n\n![Swagger](/images/swaggerapi.png)\n\n. Expand the *GET* `/products` API endpoint and select *Try It* The response body should now display an array of all the documents stored in the NoSQL database.\n+\n```\n[\n  {\n    \"_id\": \"5c3f915101ca439a6631445f\",\n    \"name\": \"consectetur anim\",\n    \"firstname\": \"Anna\",\n    \"surname\": \"Landry\",\n    \"guid\": \"df52ff12-b678-4a80-a3cf-933affd0e723\",\n    \"delivered\": true,\n    \"price\": \"$3,555.02\",\n    \"picture\": \"http://placehold.it/32x32\",\n    \"ordered\": 938,\n    \"email\": \"anna.landry@niquent.co.uk\",\n    \"phone\": \"+1 (993) 468-2139\",\n    \"address\": \"510 Fairview Place, Vowinckel, Delaware, 3513\",\n    \"about\": \"Reprehenderit id irure minim sit. Minim tempor laborum sit fugiat exercitation do Lorem cupidatat id. Enim laboris occaecat aute id voluptate mollit sit dolor. Ex occaecat labore sit nulla proident ipsum incididunt nulla officia fugiat voluptate tempor elit. Culpa amet enim voluptate veniam qui Lorem elit incididunt sint laborum id laborum. Anim occaecat commodo culpa quis aliquip dolore. Veniam nulla non et culpa.\",\n    \"created\": \"Wednesday, December 21, 2016 9:03 AM\",\n    \"latitude\": \"-34.934096\",\n    \"longitude\": \"-173.018863\",\n    \"company\": \"NIQUENT\"\n  },\n```\n. Using a NoSQL database allows for lots of flexibility for the document format and they have a lot of rich APIs.\n\n. Congratulations ! In this short exercise, you have created and deployed a Java Spring microservice and integrated to an IBM Cloud Cloudant database instance.\n\n### References\n\n-  https://console.bluemix.net/docs/services/Cloudant/getting-started.html#getting-started-with-cloudant\n- http://spring.io/projects/spring-boot\n- https://cloud.ibm.com/\n- https://cloud.ibm.com/catalog?category=databases\n- https://github.com/cloudant/java-cloudant\n","fileAbsolutePath":"/home/runner/work/ibm-garage-developer-guide/ibm-garage-developer-guide/src/pages/programming/databases/index.mdx"}}},"staticQueryHashes":["1364590287","2102389209","2102389209","2456312558","2746626797","2746626797","3018647132","3018647132","3037994772","3037994772","3273249464","63531786","63531786","768070550"]}