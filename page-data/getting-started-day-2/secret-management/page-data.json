{"componentChunkName":"component---src-pages-getting-started-day-2-secret-management-index-mdx","path":"/getting-started-day-2/secret-management/","result":{"pageContext":{"frontmatter":{"title":"Secret management"},"relativePagePath":"/getting-started-day-2/secret-management/index.mdx","titleType":"page","MdxNode":{"id":"1db3bcba-ff0e-5729-b7d6-b404f9a5d14f","children":[],"parent":"e33379a6-30a5-5c32-b816-51915fefdfc3","internal":{"content":"---\ntitle: Secret management\n---\n\nimport Globals from 'gatsby-theme-carbon/src/templates/Globals';\n\nDeploying an application into containers involves both the application logic and the associated configuration. The application\nlogic is packaged into a container image so that it can be deployed but in order to make the container image portable\nacross different environments, the application configuration should be managed separately and applied to the application\ncontainer image at deployment time.\n\nFortunately, container platforms lik <Globals name=\"ocp\" /> and <Globals name=\"kube\" /> provides a mechanism to easily \nprovide the configuration at deployment time: ConfigMaps and Secrets. Both ConfigMaps and Secrets work in the same way to \nrepresent information in key value pairs and allow that information to be attached to a running container in a number of \ndifferent ways. Unlike ConfigMaps, Secrets are intended to hold sensitive information (like passwords) and have additional access control facilities to limit who can read and use that information.\n\nWith a [GitOps](/getting-started-day-0/git-ops) approach to [continuous delivery](/getting-started-day-2/continuous-delivery),\nthe application container image and the associated configuration are represented in the Git repository together. When\nthe desired state defined in Git is applied to an environment, the relevant <Globals name=\"kube\" /> resources like Deployments,\nConfigMaps, and Secrets are generated from the provided Git configuration.\n\nA common issue when doing GitOps is how to handle sensitive information that should not be stored in the Git repository \n(e.g. passwords, keys, etc). There are two different approaches to how to handle this issue:\n\n1. Inject the values from another source into kubernetes Secret(s) at deployment time\n2. Inject the values from another source in the pod at startup time via an InitContainer\n\nThe \"other source\" in this case would be a key management system that centralizes the storage and management of sensitive \ninformation. There are a number of key management systems available to manage the secret values:\n\n- [Key Protect](/tools/secret-management-with-key-protect)\n- Hyper Protect\n- Hashicorp Vault\n\n## Use the key management system at deployment time\n\n[CD with ArgoCD](/tools/argocd) covers how to use ArgoCD to do GitOps, including how to manage sensitive information in a \nkey management system.\n\n## Use the key management system at pod startup time\n\nComing soon\n","type":"Mdx","contentDigest":"a4a1db7abc1746d9f6fca18f821658ff","counter":973,"owner":"gatsby-plugin-mdx"},"frontmatter":{"title":"Secret management"},"exports":{},"rawBody":"---\ntitle: Secret management\n---\n\nimport Globals from 'gatsby-theme-carbon/src/templates/Globals';\n\nDeploying an application into containers involves both the application logic and the associated configuration. The application\nlogic is packaged into a container image so that it can be deployed but in order to make the container image portable\nacross different environments, the application configuration should be managed separately and applied to the application\ncontainer image at deployment time.\n\nFortunately, container platforms lik <Globals name=\"ocp\" /> and <Globals name=\"kube\" /> provides a mechanism to easily \nprovide the configuration at deployment time: ConfigMaps and Secrets. Both ConfigMaps and Secrets work in the same way to \nrepresent information in key value pairs and allow that information to be attached to a running container in a number of \ndifferent ways. Unlike ConfigMaps, Secrets are intended to hold sensitive information (like passwords) and have additional access control facilities to limit who can read and use that information.\n\nWith a [GitOps](/getting-started-day-0/git-ops) approach to [continuous delivery](/getting-started-day-2/continuous-delivery),\nthe application container image and the associated configuration are represented in the Git repository together. When\nthe desired state defined in Git is applied to an environment, the relevant <Globals name=\"kube\" /> resources like Deployments,\nConfigMaps, and Secrets are generated from the provided Git configuration.\n\nA common issue when doing GitOps is how to handle sensitive information that should not be stored in the Git repository \n(e.g. passwords, keys, etc). There are two different approaches to how to handle this issue:\n\n1. Inject the values from another source into kubernetes Secret(s) at deployment time\n2. Inject the values from another source in the pod at startup time via an InitContainer\n\nThe \"other source\" in this case would be a key management system that centralizes the storage and management of sensitive \ninformation. There are a number of key management systems available to manage the secret values:\n\n- [Key Protect](/tools/secret-management-with-key-protect)\n- Hyper Protect\n- Hashicorp Vault\n\n## Use the key management system at deployment time\n\n[CD with ArgoCD](/tools/argocd) covers how to use ArgoCD to do GitOps, including how to manage sensitive information in a \nkey management system.\n\n## Use the key management system at pod startup time\n\nComing soon\n","fileAbsolutePath":"/home/runner/work/ibm-garage-developer-guide/ibm-garage-developer-guide/src/pages/getting-started-day-2/secret-management/index.mdx"}}},"staticQueryHashes":["1364590287","2102389209","2102389209","2456312558","2746626797","2746626797","3018647132","3018647132","3037994772","3037994772","3273249464","63531786","63531786","768070550"]}